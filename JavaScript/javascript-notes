/* JavaScript Numbers */
    - No different number types
    - JS uses the + operator for both addition and concatenation.
        - Numbers are added. Stings are concatenated.
        - Adding a number and a string results in a string concatenation.



/* Numeric Strings */ 
    - JS will try to convert strings to numbers in all numeric operations:
        var x = "100";
        var y = "10";
        var z = x / y;      // z will be 10
    - Division, multiplication and subtraction will all work in the above numberic calculation. However, addition (+) will result in a string.



/* NaN (Not a Number) */
    - NaN (Not a Number): a reserved word indicating that a number is not a legal number. Trying to do an arithmetic with a non-numeric string will result in NaN.
        var x = 100 / "Apple";      // x will be NaN
    - However, if the string contains a numberic value, the result will be a number.
        var x = 100 / "10";         // x will be 10
    _ You can use the global JS function `isNaN()` to find out if a value is a number:
        var x = 100 / "Apple";
        isNaN(x);                   // retunrs true because x is Not a Number
    - If you use NaN in a mathematical operation, the result will also be NaN:
            var x = NaN;
            var y = 5;
            var z = x + y;              // z will be NaN
        - Or a concatenation:
            var x = NaN;
            var y = "5";
            var z = x + y;              // z will be NaN5
    - NaN is a number 
        typeof NaN;                     // returns "number"



/* Infinity */
    - `Infinity` (or `-Infinity`) is the value JS will return if you calculate a number outside the largest possible number.
        var myNumber = 2;
        while (myNumber != Infinity) {      // Execute until Infinity
            myNumber = myNumber * myNumber;
        }
    - Division by 0 (zero) also generates Infinity
        var x = 2 /0;           // x will be Infinity
        var y = -2 / 0;         // x will be -Infinity
    - `Infinity` is a number: `typeof Infinity` returns `number`.
        typeof Infinity;        // returns "number"



/* Hexadecimal */
    - JS interprets numeric constants as hexadecimal if they are preceded by 0x.
        var x = 0xFF;           // x will be 255
    - NEVER WRITE A NUMBER WITH A LEADING ZERO (LIKE 07). SOME JS VERSIONS INTERPRET NUMBERS AS OCTAL IF THEY ARE WRITTEN WITH A LEADING ZERO.
    - By default, JS desplays numbers as 'base 10' decimals, but you can use the `toString()` method to output numbers from 'base 2' to 'base 36'. Hexadecimal is 'base 16', decimal is 'base 10', octal is 'base 8' and binary is 'base 2'.
        var myNumber = 32;
        myNumber.toString(10);  // returns 32
        myNumber.toString(32);  // returns 10
        myNumber.toString(16);  // returns 20
        myNumber.toString(8);   // returns 40
        myNumber.toString(2);   // returns 100000



/* Numbers Can be Objects */
    - Normally JS numbers are primitive values created from literals
        var x = 123;                    // typeof x returns number
    - Numbers can also be defined as objects with the keyword `new`:
        var y = new Number(123);        // typeof y returns objects
    - DO NOT CREATE NUMBER OBJECTS. IT SLOWS DOWN EXECUTION SPEED.
        - The `new` keyword complicates the code. This can reproduce some unexpected results.
    - When using the `==` operator, equal numbers are equal:
        var x = 500;
        var y = new Number(500);
            // (x == y) is true because x and y have equal values
    - When using the === operator, equal numbers are not equal, beause the === operator EXPECTS EQUALITY IN BOTH TYPE AND VALUE.
        var x = 500;
        var y = new Number(500);
            // (x === y) is false because x and y have different types
    - Objects cannot be compared
        var x = new Number(500);
        var y = new Number(500);
            // (x == y) is false because objects cannot be compared
        - COMPARING TWO JS OBJECTS WILL ALWAYS RETURN `false`



/* JS Arithmetic Operators */
    - Arithmetic operators perform arithmetic on numbers (literals or variables).
        Operators           Description
            +                   addition
            -                   subtraction
            *                   multiplication
            **                  exponentation
            /                   Division
            %                   modulus (remainder)
            ++                  increment
            --                  decrement



/* Arithmetic operations */
    - A typical arithmetic operation operates on two numbers
        - The two numbers can be literals:
            var x = 100 + 50;
        - Or variables:
            var x = a + b;
        - Or expressions:
            var x = (100 + 50) * a;
    


/* Operators and Operands */
    - The numbers (in an arithmetic operation) are call operands.
    - The operation (to be performed betwee the two operands) is defined by an operator.
    - Adding
        The addition operator (+) add numbers:
            var x = 5;
            var y = 2;
            var z = x + y;
    - Subtracting
        The subtration operator (-) subtracts numbers:
            var x = 5;
            var y = 2;
            var z = x - y;
    - Multiplying
        The multiplication operator (*) multiplies numbers:
            var x = 5;
            var y = 2;
            var z = x * y;
    - Dividing
        The division operator (/) divides numbers:
            var x = 5;
            var y = 2;
            var z = x / y;
    - Remainder
        The modulus operator (%) returns the division remainder:
            var x = 5;
            var y = 2;
            var z = x % y;
        In arithmetic, the division of two integers produces a quotient and a remainder.
        In mathematics, the result of the modulo operation is the remainder of an arithmetic division.
    - Incrementing
        The increment operator (++) increments numbers:
            var x = 5;
            x++;
            var z = x;
    - Decrementing
        The decrement operator (--) decrements numbers:
            var x = 5;
            x--;
            var z = x;
    - Exponentiation
        The exponentiation operator (**) raises the first operand to the power of the second operand:
            var x = 5;
            var z = x ** 2;     // result is 25
        x ** y produces the same result as `Math.pow(x,y)`:
            var x = 5;
            var z = Math.pow(x,2);     // result is 25

    - Terms: "unary", "binary"
        An operator is 'unary' if it has a single operand (x = 3). For example, the unary negation `-` reverses the sign of a number:
            let x = 1;
            x = -x;
            alert(x);       // -1, unary negation was applied
        An operator is 'binary' if it has two operands (x=1, y=3). The same `-` exists in binary form as well:
            let x = 1, y = 3;
            alert( y-x );   // 2, binary minus subtracts values
        - In the examples above, we have two different operators that share the same symbol: the negation operator, a unary operator that reverses the sign, and the subtraction operator, a binary operator that subtracts one number from another.

    - Numberic conversion, unary +
        The plus (+) exists in two forms: the binary form and the unary form.
            The unary plus or, aka the + operator, applied to a single value doesn't do anything to numbers. But if the operand is not a number, the unary plus converts it into a number.
                // No effect on numbers
                    let x = 1;
                    alert( +x );        // 1

                    let y = -2;
                    alert( +y );        // -2

                // Converts non-numbers
                    alert( +true );     // 1
                    alert( +"" );       // 0
                        // This does the same thing as `Number(...)`, but is shorter.
            
                // Example conversion using input values from a <form>
                    let apples = "2";
                    let oranges = "3";

                    // both values converted to numbers before the binary plus
                    alert( +apples + +oranges );   // 5

                    // the longer variant
                    alert( Number(apples) + Number(oranges) );  //5
            Unary pluses are applied first, they convert strings to numbers, and then the binary plus sums them up.
        
    - Chaining assignments
        Chained assignments evaluate from RIGHT to LEFT. 
            let a, b, c;

            a = b = c = 2 + 2;

            alert( a ); // 4
            alert( b ); // 4
            alert( c ); // 4
                // First, the rightmost expression (2 + 2) is evaluated and then assigned to the variables on the left: c, b and a (in that order). At the end, all the variables share a single value.
                // For the purposes of readability it's better to split such code into a few lines.
    
    - Modify-in-place
        Applying an operator to a variable and storing the new result in the same variable.
            let n = 2;
            n = n + 5;
            n = n * 2;      // n = 14
        Notation can be shortend using the operators += and *=
            let n = 2;
            n += 5;
            n *= 2;         // n = 14
        Such operators have the same precedence as the normal assignment, so they run after most other calculations.
            let n = 2;
            n *= 3 + 5;
            alert( n );     // 16 (right part evaluated first, same as n *= 8) 
        
    - Increment/decrement
        CAN ONLY BE APPLIED TO VARIABLES!
        The operators ++ and -- can be placed either before or after a variable.
            When the operator goes after the variable, it is in "postfix form": a++
            When the operator goes in front of the variable, it is in "prefix form": ++a
                The prefix form returns the new value while the postfix form returns the old value (prior to increment/decrement).
                    // Prefix example
                        let counter = 1;
                        let a = ++counter:      // (*)
                        alert( a ):             // 2
                        // In the line (*), the prefix form `++counter` increments `counter` and returns the new value, 2. So, the `alert` shows `2`.
                    // Postfix example
                        let counter = 1;
                        let a = counter++;      // (*) changed ++counter to counter++
                        alert( a );             // 1
                        // In the line (*); the postfix form `counter++` also increments `counter` but returns the old value (prior to increment). So the `alert` shows 1.
        If the result of increment/decrement is not used, there is no difference in which form to use.
            To increase the value and immediately use the result of the opeartor, use the PREFIX form.
            To increase the value but use the previous value, use the POSTFIX form.
        The operators ++/-- can be used inside expressions as well. Thier precedence is higher than most other arithmetical operations.

    - Bitwise operators
        Bitwise operators treat arguments as 32-bit integer numbers and work on the level of their binary representation.
        These operators are not JS-specific. They are supported in most programming languages.
            AND ( & )
            OR ( | )
            XOR ( ^ )
            NOT ( ~ )
            LEFT SHIFT ( << )
            RIGHT SHIFT ( >> )
            ZERO-FILL RIGHT SHIFT ( >>> )
        These operators are used very rarely, when we need to fiddle with numbers on the very lowest (bitwise) level. 
            Web development has little use for bitwise operators.
            In some special areas, such as cryptography, they are useful.

    - Comma 
        One of the rarest and most unusual operators. Sometimes, used to write shorter code.
            Allows us to evaluate several expressions, dividing them with a comma (,). 
            Each of them is evaluated but only the result of the last one is returned.
                let a = (1+2, 3+4);
                alert ( a );        // 7 (the result of 3+4)
        Comma operators have very low precedence, lower than =, so parentheses are important in the above example.
            Without them: `a = 1+2, 3+4;` evaluates + first, summing the numbers into `a = 3, 7`, then the assignment operator = assigns `a = 3`, and the rest is ignored. 
                Equivalent to `(a = 1 + 2), 3 + 4;`
        Commas are commonly used in more complex constructs to put seeral actions in one line.
            for (a = 1, b = 3, c = a * b; a < 10; a++) {
                ...
            }
            // three operations in one line
        Such tricks are used in many JS frameworks. That's why we're mentioning them, but usually they don't improve code readability so we should think well before using them.



/* Operaotr Precedence */
    - Operator Precedence
        Operator precedence describes the order in which operations are performed in an arithmetic expression.
        Multiplication (*) and division (/) have higher precedence than addition (+) and subtraction (-).
        The precedence can be changed by using parentheses.
        When many operations have the same precedence (like addition and subtraction), there are computed fom left to right.



/* JavaScript Operator Precedence Values */
    Value           Operator          Description                                        Example
        20              ( )             Expression grouping                                 (3+4)

        19              .               Member                                              person.name
        19              []              Member                                              person["name"]
        19              ()              Function call                                       myFunction()
        19              new             Create                                              new Date()

        17              ++              Postfix Increment                                   i++
        17              --              Postfix Decrement                                   i--

        16              ++              Prefix Increment                                    ++i
        16              --              Prefix Decrement                                    --i
        16              !               Logical not                                         !(x==y)
        16              typeof          Type                                                typeof x

        15              **              Exponentiation (ES2016 or higher)                   10 ** 2

        14              *               Multiplication                                      10 * 5
        14              /               Division                                            10 / 5
        14              %               Division Remainder                                  10 % 5

        13              +               Addition                                            10 + 5
        13              -               Subtraction                                         10 - 5

        12              <<              Shift Left                                          x << 2
        12              >>              Shift Right                                         x >> 2
        12              >>>             Shift Right (unsigned)                              x >>> 2

        11              <               Less than                                           x < y
        11              <=              Less than or equal                                  x <= y
        11              >               Greater than                                        x > y
        11              >=              Greater than or equal                               x >= y
        11              in              Property in Object  (ES2016 or higher)              "PI" in Math 
        11              instanceof      Instance of Object  (ES2016 or higher)              instanceof Array

        10              ==              Equal                                               x == y
        10              ===             Strict equal                                        x === y 
        10              !=              Unequal                                             x != y
        10              !==             Strict unequal                                      x !== y

        9               &               Bitwise AND                                         x & y
        8               ^               Bitwise XOR                                         x ^ y
        7               |               Bitwise OR                                          x | y
        6               &&              Logical AND                                         x && y 
        5               ||              Logical OR                                          x || y 
        4               ?:              Condition                                           ? "Yes : "No"

        3               +=              Assignment (modify-in-place)                        x += y
        3               /=              Assignment (modify-in-place)                        x /= y 
        3               -=              Assignment (modify-in-place)                        x -= y
        3               *=              Assignment (modify-in-place)                        x *= y 
        3               %=              Assignment (modify-in-place)                        x %= y 
        3               <<=             Assignment                                          x <<= y
        3               >>=             Assignment                                          x >>= y
        3               >>>=            Assignment                                          x >>>= y 
        3               &=              Assignment                                          x &= y
        3               ^=              Assignment                                          x ^= y
        3               |=              Assignment                                          x |= y 

        2               yield           Pause Function (ES2016 or higher)                   yield x 

        1               ,               Comma                                               5, 6

    - EXPRESSION IN PARENTHESES ARE FULLY COMPUTED BEFORE THE VALUE IS USED IN THE REST OF THE EXPRESSION.
    


/* Variables */
    - A "named storage" for data. Can be used to store goodies, visitors, and other data.
    - `let` keyword  
        Used to create a variable in JS
            let message;
        Now, we can put some data into it by using the assignment operator =:
            let message;
            message = 'Hello";      // store the string
        The string is now saved into the memory area associated with the variable and can be accessed using the variable name:
            let message:
            message = 'Hello!';
            alert( message );       // shows the variable concatenated
        The variable declaration and assignment can be combined into a single line:
            let message = 'Hello!';
            alert ( message );
        Multiple variables can be declared in one line (separated by a comma):
            let user = 'John', age = 25, message = 'Hello';
                NOT RECOMMENDED - for the sake of better readability, use a single line per variable 
                    let user = 'John',
                        age = 25,
                        message = 'Hello';
        `let` provides block-scoping that is absent in the fucntion-scoped `var`
            Example     var callbacks = [];
                        (function() {
                            for (let i = 0; i < 5; i++) {
                                callbacks.push( function() { return i; } );
                            }
                        })();
                        console.log(callbacks.map( function(cb) { reutnr cb(); } ));
            `let` stats in the block scope of the loop, causing a separate instance of i for each iteration.
            `var` would be hoisted(?) to the top of the function's scope 

    - `var` keyword
        In older scripts, you may also find the keyword `var`, used to declare variables
            var message = 'Hello';
        `var` is still useful in situations where you want to maintain function scope instead of block scope 
        
    - Changing variable values 
        Variable values can be changed as many times as we want:
                let message;
                message = 'Hello!';
                messgae = 'World!';
                alert( message );       // prints 'World!'
            When the value is changed, the old data is removed from the variable.

    - Copying data between variables
        Data can be copied from one variable to another   
            let hello = 'Hello world!';
            let message;
            message = hello;            // copy 'Hello world' from hello into message
            // now two variables hod the same data
            alert( hello );             // Hello world!
            alert( message );           // Hello world!

    - Declaring variables twice
        DECLARING TWICE TRIGGERS AND ERROR
            A variable should be declared only once
            A repeated declaration of the same variable is an error 
                let message = "this";
                let message = "that";   // SyntaxError: 'message' has already been declared
            Once a variable is declared, it should be referred to WITHOUT the keyword `let`

    - Variable naming
        There are two limitations on variable names in JS:
            1) The name must contain only letters, digits, or the symbols $ and _
            2) The first character must NOT be a digit
                let userName;
                let test123;
        When a name contains multiple words, camelCase is commonly used. 
            That is, words go one after another, each word except the first starting with a capital letter. 
            Ex: lutherCalvinRiggs
        The dollar sign ($) and the underscore (_) can also be used in names. They are regular symbols, just like letters, without any special meaning.
            let $ = 1;
            let _ = 2;
            alert( $ + _ );     // 3
        Examples of incorrect variable names:
            let 1a;             // cannot start with a digit
            let my-name;        // hyphens (-) aren't allowed in the name
        Case matters: variables named `apple` and `ApplE` are two different variables
        Non-Latin letters are allowed, but not recommended   
            It is possible to use any language, including cyrillic letters or even hieroglyphs, however, there is an international convention to use English in variable names.
            If your code has a long life, people from other countries may need to read it in the future.
        Reserved names  
            This is a list of reserved words which CANNOT be used as variable names because they are used by the language itself:
                let
                class
                return
                function 
        
    - `use strict`
        Normally, we need to define a variable before using it. But in the old times, it was technically possible to create a variable by a mere assignment of the value without using `let`. This still works now if we don't put `use strict` in our scripts to maintain compatibility with old scripts.
            // note: no "use strict" in this example
            num = 5;            // the variable "num" is created if it didn't exist
            alert( num );       // 5
            
            "use strict";
            num = 5;            // error: num is not defined 
    
    - Constants
        To declare a constant (unchanging) variable, use `const` instead of `let`:
            const myBirthday = '18.04.1982';
        Variables decared using `const` CANNOT by reassigned. An attempt to do so would cause an error:
            const myBirthday = '18.04.1982';
            myBirthday = '01.01.2001':          // error, can't reassign the constant!
                `const` will throw an error is an attempt is made to change its value after it has been declared, a useful feature to prevent accidental mutation.
        When a programmer is use that a variable will never change, they can declare it with `const` to guarantee and clearly communicate that fact to everyone
    - Uppercase constants 
        There is a widespread practice to use constants as aliases for difficult-to-remember values that are known prior to execution. 
        Such constants are named using capital letters and uncerscores
            Example of constants for collors in so-called "web" (hexadecimal) format:
                const COLOR_RED = "#F00"
                const COLOR_GREEN = "#0F0"
                const COLOR_BLUE = "#00F"
                const COLOR_ORANGE = "#FF7F00";
                // ...when we need to pick a color 
                let color = COLOR_ORANGE;
                alert( color );                     // #FF7F00
            Benefits:
                COLOR_ORANGE is much easier to remember than #FF7F00 
                It is much easier to mistype #FF7F00 than COLOR_ORANGE
                When reading the code, COLOR_ORANGE is much more meaningful than #FF7F00
            USE CAPITALS WHEN THE CONSTANTS ARE KNOWN PRIOR TO EXECUTION AND THERE ARE CONSTANTS THAT ARE CALCULATED IN RUN-TIME, DURING THE EXECUTION, BUT DO NOT CHANGE AFTER THEIR INITIAL ASSIGNMENT.
                In other words, capital-named constants are only used as aliases for "hard-coded" values 
    
    - Name things right
        A variable name should have a clean, obvious meaning, describing the data that it stores
            One of the things that separates the beginners from the experienced developers
            In a real project, most fo the time is spent modifying and extending an existing code base rather than writing something completely separate from scratch. When we return to some code after doing something else for a while, it's much easier to find information that is well-labeled, or uses good variable names.
            Some variable naming rules are:
                Use human-readable names like `userName` or `shoppingCart`
                Stay way from abbreviations or short names like `a, b, c`, unless you really know what you're doing
                Make names maximally descriptive and concise. Names like `data` and `value` are bad because they are too broad. Only use broad names if the context of the code makes it exceptionally obvious which data or value the variable is referencing.
                Agree on terms within your team and in your own mind. If a site visitor is called a "user" then we should name related variables `currentUser` or `newUser` instead of `currentVisitor` or `newManInTown`

    - Reuse or create
        Reusing variables is like having boxes into which people throw different things without changing their stickers. What's in the box now? Who knows? 
        This may save a little bit on variable declaration, but will lose ten times more on debugging
        EXTRA VARIABLES ARE GOOD 
            Modern JS minifiers and browsers optimize code well enough, so it won't create performance issues. 
            Using different variables for different values can even help the engine optimize your code.
    
    - Variables should be named in a way that allows us to easily understand what's inside them.



/* Data Types */
    - A value in JS is always of a certain type. For example, a string or a number.
    - There are eight basic data types in JS 
    - We can put any type in a variable. For example, a variable can at one moment be a string and then store a number.
        // no error
        let message = "hello";
        message = 123456;
    - Programming languages that allow such things, such as JS, are called "dynamically typed", meaning that there exists data types, but variables are not bound to any of them.

    - Number
            let n = 123;
            n = 12.345;
        The number type represents both integer and floating point numbers.
        Beyond regular numbers, there are so-called "special numberic values" which also belong to this data type: 
            `Infinity` 
                Represents the mathematical Infinity and is a special value that's greater than any number
                We can get it as a result of division by zero 
                    alert( 1 / 0 );        // Infinity
                Or just reference it directly
                    alert( Infinity );      // Infinity
            `-Infinity` 
            `NaN`
                Represents a computational error. It is a result of an incorrect or an undefined mathematical operation, for instance:
                    alert( "not a number" / 2 );        // NaN, such division is erroneous
                NaN is sticky. Any further operation on NaN reutnrs NaN:
                    alert( "not a number" / 2 + 5 );    // NaN 
        Special numberic values formally belong to the "number" type. Of course they are not numbers in the common sense of this word.
            Doing maths is "safe" in JS. We can do anything: divide by zero, treat non-nmeric strings as numbers, etc.
            The script will never stop with a fatal error ("die"). At worst, we'll get NaN as the result.

    -BigInt
        In JS, the "number" type cannot represent integer values larger than (2^53-1), (or 9007199254740991), or less than -(-2^53-1) for negatives. It's a technical limitation caused by their internal representation.
        For most purposes that's quite enough, but sometimes we need really big numbers, eg for cryptography or microsecond-precision timestamps.
        `BigInt` type was recently added to the language to represent integers of arbitrary length.
        A `BigInt` value is created by appending `n` to the end of an integer:
            // the "n" at the end means it's a BigInt
            const bigInt = 1234567890123456789012345678901234567890n;
        Right now `BigInt` is supported in Firefox/Chrome/Edge, but not in Safari/IE. (7.1.2020)

    - String
        A STRING IN JS MUST BE SURROUNDED BY QUOTES

        In JS, there are 3 types of quotes:

            Double and single quotes are "simple" quotes. There's practically no difference between them in JS.

                Double quotes: "Hello"
                    let str = "Hello";
                Single quotes: 'Hello'
                    let str2 = 'Single quotes are ok too';

            Backticks are "extended functionality" quotes. They allow us to embed variables and expressions into a string by wrapping them in ${_}. The expression inside ${...} is evaluated and the result becomes a part of the string. Anything can be put into the ${...}
               
                Backticks: `Hello`

                    let phrase = `can embed another ${str}`;

                    let name = "John";

                    // embed a variable
                    alert( `Hello, ${name}!` );         // Hello, John!

                    // embed an expression
                    alert( `the result is ${1+2}` );    // the result is 3

        There is no 'character' type.

            In some languages, there is a special "character" type for a single character. For example, in the C language and in Java it is called "char".

            In JS, there is no such type. There's only one type: `string`. A string may consist of only one character or many of them.
    
    - Boolean (logical type)
        The boolean type has only two values: `true` and `false`
        This type is commonly used to store yes/no values: `true` means "yes, correct", and `false` means "no, incorrect".
            let nameFieldChecked = true;        // yes, name field is checked 
            let ageFieldChecked = false;        // no, age field is not checked 
        Boolean values also come as a result of comparisons:
            let isGreater = 4 > 1;
            alert( isGreater );         // true (the comparison result is "yes")
        
    - The "null" value 
        The special `null` value does not belong to any of the types described above.
        It forms a separate type of its own which contains only the `null` value:
            let age = null;
            // This code states that `age` is unknown 
        In JS, `null` is not a "reference to a non-existing object" or a "null pointer" like in some other languages. It's just a special value which represents "nothing", "empty" or "value unknown".
    
    - The "undefined" value 
        The special value `undefined` also stands apart. It makes a type of its own, just like `null`.
        The meaning of `undefined` is "value is not assigned"
        If a variable is declared, but not assigned, then its value is `undefined`:
            let age;
            alert( age );       // shows "undefined"
        Technically, it is possible to explicitly assign `undefined` to a variable:
                let age = 100;
                // change the value to undefined 
                age = undefined;
                alert( age );       // "undefined"
            ...But this is not recommended. 
        Normally, one uses `null` to assign an "empty" or "unknown" value to a variable, while `undefined` is reserved as a default initial value for unassigned things. 

    - Objects and Symbols
        The `object` type is special.
            All other types are called "primitive" because their values can contain only a single thing (be it a string or a number or whatever). In contrast, objects are used to store collections of data and more complex entities.
        The `symbol` type is used to create unique identifiers for objects.

    - The typeof operator 
        The `typeof` operator returns the type of the argument. It's useful when we want to process values of different types differently or just want to do a quick check. 
        It supports to forms of syntax (meaning it works with parentheses or without them):
            1) As an operator: `typeof x`
            2) as a function: `typeof(x)`
        The call to `typeof x` returns a string with a type name:
            typeof undefines            // "undefined"
            typeof 0                    // "number"
            typeof 10n                  // "bigint"
            typeof true                 // "boolean"
            typeof "foo"                // "string"
            typeof Symbol("id")         // "symbol"
            typeof Math                 // "object"
                // `Math` is a built-in object that provides mathematical operations.
            typeof null                 // "object"
                // This is an officially recognized error in `typeof` behavior, coming from the early days of JS and kept for compatibility. Definitely, `null` is not an object. It is a special value with a separate type of its own.
            typeof alert                // "function"
            


/* Strings */
    - A string is simply a piece of text. 
    - String methods help you to work with strings.

    - String Methods and Properties

        Primitive values, like "John Doe", cannot have properties or methods (because they are not objects).

        Yet, JS treats primitive values as objects when executing methods and properties.

    - String length

        The `length` property returns the length of a string 

            let txt = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            let sln = txt.length;           // 26
    
    - Finding a string in a string

        The `indexOf()` method returns the index of (the position of) the `first` occurrence of a specified text in a string:

            let str = "Please locate where 'locate' occurs!";
            let pos = str.indexOf("locate");        // 7

        JS counts positions from zero (0)

        The `lastIndexOf()` method returns the index of the last occurence of a specified text in a string.

            let str = "Please locate where 'locate' occurs!";
            let pos = str.lastIndexOf("locate");    // 21

        Both `indexOf()` and `lastIndexOf()` return -1 if the text is not found.

            let str = "Please locate where 'locate' occurs!";
            let pos = str.lastIndexOf("John");    // -1 

        Both methods accept a second parameter as the starting position for the search:

            let str = "Please locate where 'locate' occurs!";
            let pos = str.indexOf('locate", 15);    // 21

        The `lastIndexOf()` method searches backwards (from the end to the beginning), meaning: if the second parameter is `15`, the search starts at position 15, and searches to the beginning of the string.

            let str = "Please locate where 'locate' occurs!";
            let pos = str.lastIndexOf("locate", 15);    // 7

    - Searching for a String in a String 

        The `search()` method searches a string for a specified value and returns the position of the match:

            let str = "Please locate where 'locate' occurs!";
            let pos = str.search("locate");         // 7
        
    - The indexOf() and search() method are NOT equal

        The search() method cannot take a second start position argument.

        The indexOf() method cannot take powerful search values (regular expressions).

    - Extracting string parts 

        There are 3 methods for extracting a part of a string:

            The slice() Method: `slice(start, end)`

                `slice()` extracts a part of a string and returns the extracted part in a new string.

                This method takes two paramenters:

                    The start position 

                    The end position (end not included)
                        let str = "Apple, Banana, Kiwi";
                        let res = str.slice(7, 13);         // Banana

                    If a parameter is negative, the position is counted from the end of the string.

                        let str = "Apple, Banana, Kiwi";
                        let res = str.slice(-12, -6);       // Banana

                    If you omit the second parameter, the method will slice out the rest of the string:

                        let str = "Apple, Banana, Kiwi";
                        let res = str.slice(7);             // Banana, Kiwi 

                        let str = "Apple, Banana, Kiwi";
                        let res = str.slice(-12);           // Banana, Kiwi 

            The substring() Method: `substring(start, end)`

                Similar to slice(), however, substring() cannot accept negative indexes.

                    let str = "Apple, Banana, Kiwi";
                    let res = str.substring(7, 13);             // Banana

                If you omit the second parameter, substring() will slice out the rest of the string.

            The substr() Method: `substr(start, length)`

                Similar to slice(), however, the second parameter specifies the length of the extracted part.

                    let str = "Apple, Banana, Kiwi";
                    let res = str.slice(7, 6);             // Banana

                If you omit the second parameter, substr() will slice out the rest of the string.

                    let str = "Apple, Banana, Kiwi";
                    let res = str.slice(7);             // Banana, Kiwi 

                If the first parameter is negative, the position counts from the end of the string.

                    let str = "Apple, Banana, Kiwi";
                    let res = str.slice(-4);             // Kiwi 

    - Replacing string content 

        The replace() method replaces a specified value with another value in a string:

            str = "Please visit Microsoft!";
            let n = str.replace("Microsoft", "W3Schools");      // Please visit W3Schools!
        
        THE replace() METHOD DOES NOT CHANGE THE STRING IT IS CALLED ON. IT RETURNS A NEW STRING.
        
        By default, the replace() method replaces ONLY THE FIRST MATCH.

            str = "Please visit Microsoft and Microsoft!";
            let n = str.replace("Microsoft", "W3Schools");      // Please visit W3Schools and Microsoft!
        
        By default, the replace() method is CASE SENSITIVE

            str = "Please visit Microsoft!";
            let n = str.replace("MICROSOFT", "W3Schools");      // Please visit Microsoft!

        To replace case insensitive, use a regular expression with an `/i` flag (insensitive):

            str = "Please visit Microsoft!";
            let n = str.replace(/MICROSOFT/i, "W3Schools");     // Please visit W3Schools!
                NOTE THAT REGULAR EXPRESSIONS ARE WRITTEN WITHOUT QUOTES

        To replace ALL MATCHES, use a regular expression with a `/g` flag (global match):

            str = "Please visit Microsoft and Microsoft!";
        let n = str.replace(/MICROSOFT/g, "W3Schools");         // Please visit W3Schools and W3Schools!

    - Converting to Upper and Lower Case

        `toUpperCase()` converts a string to upper case:

            let text1 = "Hello World!";
            let text2 = text1.toUpperCase();  // HELLO WORLD!

        `toLowerCase()` converts a string to lower case:

            let text1 = "Hello World!";
            let text2 = text1.toLowerCase();  // hello world!

        To capitalize only the first letter of a string, use the following code:

            string.substring(0, 1).toUpperCase + string.substring(1);
    
    - The concat() Method

        `concat()` joins two or more strings:

            let text1 = "Hello";
            let text2 = "World";
            let text3 = text1.concat(" ", text2);       // Hello World 
                // This method takes text1, adds a space (" "), then adds text2

        The `concat()` method can be used instead of the plus operator. 

            These two lines do the same thing:

                let text = "Hello" + " " + "World!";
                let text = "Hello".concat(" ", "World!");
        
    ALL STRING METHODS RETURN A NEW STRING. THEY DON'T MODIFY THE ORIGINAL STRING.
        Formally said: Strings are immutable - they cannot be changed, only replaced.

    - String.trim()
        The `trim()` method removes whitespace from both sides of a string:
            let str = "          Hello World!         "
            alert(str.trim());          // Hello World!
        THE trim() METHOD IS NOT SUPPORTED IN IE 8 OR Lower
            If you need to support IE 8 , you can use `replace()` with a regular expression instead:
                let str = "       Hello World!        ";
                alert(str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''));
            You can also use the replace solution above to add a trim function to the JS `String.prototype`:
                if (!String.prototype.trim) {
                    String.prototype.trim = function() {
                        return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
                    };
                }
                let str = "             Hello World!             ";
                alert(str.thrim());
    
    - Extracting String Characters
        There are 3 methods for extracting string Characters:
            The `charAt()` method returns the character at a specified index (position) in a string:
                let str = "HELLO WORLD";
                str.charAt(0);              // returns H 
            The `charCodeAt()` method returns the unicode of the character a the specified index in a string:
                The method returns a UTF-16 code (an integer between 0 and 65535)
                    let str = "HELLO WORLD";
                    str.charCodeAt(0);      // returns 72
            Property Access []
                ECMAScript 5 (2009) allows property access [] on strings:
                    let str = "HELLO WORLD";
                    str[0];                 // returns H 
                PROPERTY ACCESS MIGHT BE A LITTLE UNPREDICTABLE:
                    It does not work in IE 7 or earlier
                    It makes strings look like arrays (THEY ARE NOT)
                    If no character is found, [] returns undefined, while charAt() returns an empty string
                    It is read only. str[0] = "A" give no error (but does not work!)
                        let str = "HELLO WORLD";
                        str[0] = "A";               // give no error, but does not work
                        str[0];                     // returns H
    
    IF YOU WANT TO WORK WITH A STRING AS AN ARRAY, YOU CAN CONVERT IT TO AN ARRAY.
    - Converting a string to an Array
        The `split()` Method is used to convert a string into an array.
            let txt = "a,b,c,d,e";          // string 
            txt.split(",");                 // split on commas
            txt.split(" ");                 // split on spaces 
            txt.split("|");                 // split on pipe 
        If the SEPARATOR IS OMITTED, the returned array will contain the whole string in index [0].
        If the SEPARATOR IS "", the returned array will be an array of single characters.
            let txt = "Hello";              // string 
            txt.split("");                  // split in characters 
    
    - Complete string reference 
        For a complete reference, go to https://www.w3schools.com/jsref/jsref_obj_string.asp
            The reference contains descriptions and examples of all string properties and methods.

        For an exhaustive list of methods that can be used on strings, go to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String



/* Conditionals */
    - Comparisons 
        We know many comparison operators from maths.
        In JS they are written like this:
            Greater/less than: a > b, a < b
            Greater/less than or equals: a >= b, a <= b
            Equals: a == b   Please note the double equality sign means the equality test while a single = means assignment. 
            Not equals: a != b

    - Boolean is the result
        ALL COMPARISON OPERATORS RETURN A BOOLEAN VALUE 
            true - means "yes", "correct" or "the truth"
            false - means "no", "wrong" or "not the truth"
                alert( 2 > 1 );     // true (correct)
                alert( 2 == 1 );    // false (wrong)
                alert( 2 != 1 );    // true (correct)
        A comparison result can be assigned to a varialbe, just like any value:
            let result = 5 > 4; // assign the result of the comparison
            alert ( result );   // true
    
    - String comparison
        To see whether a string is great than another, JS uses the so-called "dictionary" or "lexicographical" order. 
        STRINGS ARE COMPARED LETTER-BY-LETTER
            alert( 'Z' > 'A' );         // true
            alert( 'Glow' > 'Glee' );   // true
            alert( 'Bee' > 'Be' );      // true
        The algorithm to compare two strings is simple:
            1. Compare the first character to both strings.
            2. If the first character from the first string is greater (or less) than the other string's, then the first string is greater (or less) than the second. We're done.
            3. Otherwise, if both strings' first characters are the same, compare the second characters the same way.
            4. Repeat until the end of either string.
            5. If both strings end at the same length, then they are equal. Otherwise, the longer string is greater.
                Not a real dictionary, but Unicode order    
                    The comparison algorithm given above is roughly equivalent to the one used in dictionaries or phone books, but it's not exactly the same. 
                    For instance, case matters. A capital letter 'A' is not equal to the lowercase 'a'. Which one is greater? The lowercase 'a', because the lowercase character has a greater index in the internal encoding table JS uses (Unicode). 
    
    - Comparison of different types 
        When comparing values of different types, JS converts the values to numbers.
            alert( '2' > 1 );       // true, string '2' becomes a number 2
            alert( '01' == 1 ):     // true, string '01' becomes the number 1
        For bolean values, `true` becomes '1' and `false` becomes '0'
            alert( true == 1 );     // true
            alert( false == 0 );    // true
        IT IS POSSIBLE THAT AT THE SAME TIME:   
            Two values are equal
            One of them is `true` as a boolean and the other one is `false` as a boolean 
                let a = 0;
                alert( Boolean(a) );        // false
                let b = "0";
                alert( Boolena(b) );        // true
                alert( a == b );            // true
                    - From the JS standpoint, this result is quite normal. An equality check converts values using the numeric conversion (hence "0" becomes 0), while the explicit Boolean conversion uses another set of rules. 
    
    - Strict equality 
        A regular equality check == has a problem. It cannot differentiate 0 from `false`.
            alert ( 0 == false );       // true 
        The same thing happens with an empty string:
            alert( '' == false );       // true
        This happens because operands of different types are converted to numbers by the equaltiy operat ==. An empty string, just like `false`, becomes a 0.
        To differentiate `0` from `false`, a STRICT EQUALITY OPERATOR `===` checks the equality without type conversion.
            In other words, if a and b are of different types, then `a === b` immediately returns `false` without an attempt to convert them. 
                alert( 0 === false );       / false, because the types are different 
            There is also a "strict non-equality" operator `!==` analogous to `!=`
                The strict equalty operator is a bit longer to write, but makes it obvious what's going on and leaves less room for errors. 
    
    - Comparison with null and undefined 
        There's a non-intuitive behavior when `null` or `undefined` are compared to other values. 
        For a strict quality check `===`
            These values are differen, becaue each of them is a different type:
                alert( null === undefined );        // false
        For a non-strict check `==`
            There's a speacial rule. These two are a "sweet couple": they equal each other ( in the sense of `==`), but not any other value. 
                alert( null == undefined );         // true 
        For maths and other comparisons `< > <= >=`
            `null/undefined` are converted to numbers: `null` becomes `0`, while undefined becomes `NaN`
            Funny things happen when we apply these rules. Also, how not to fall into a trap with them.
                Strange result: null vs 0
                    alert( null > 0 );      // false (1)
                    alert( null == 0 );     // false (2)
                    alert( null >= 0 );     // true (3)
                    Mathematically, that's strange. The last result states that `null` is greater than or equal to zero, meaning one of the other comparisons should also be true, but they are not. 
                        (1, 3) An equality check `==` and comparisons `> < >= <=` work differently. Comparisons convert `null` to a number, treating it as `0`. That is why `null >= 0` is true and `null > 0` is false. 
                        (2) On the other hand, the equality check `==` for `undefined` and `null` is defined such that, without conversions, they equal each other and don't equal anything else. That's why `null == 0` is false.
                An incomparable undefine 
                    The value `undefined` shouldn't be compared to other values: 
                        alert( undefined > 0 );         // false (1)
                        alert( undefined > 0 );         // false (2)
                        alert( undefined == 0 );        // false (3)
                    Comparison (1) and (2) return `false` because `undefined` gets converted to `NaN` and `NaN` is a special numeric value which returns `false` for all comparisons 
                    The equality check (3) returns `false` because `undefined` only equals `null`, `undefined`, and no other value. 
                Avoid problems
                    These tricky things will gradually become familiar over time, but there's a solid way to avoid problems with them:
                        Treat any comparison with `undefined/null` except the stric equality `===` with exceptional care.
                        Don't use comparision `>= > < <=` with a variable which may be `null/undefined`, unless you're really sure of hat you're doing. If a variable can have these values, check for them separately.
    
    - Summary
        Comparison operators return a boolean value.
        Strings are compared letter-by-letter in the "dictionary" order
        When values of different types are compared, they get converted to numbers (with the exclusion of a strict equality check).
        The values `null` and `undefined` equal (==) each other and do not equal any other value.
        Be careful when using comparisons like `>` or `<` with variables that can occasionally be `null/undefined`. Checking for `null/undefined` separately is a good idea. 



/* Conditional if else / else if Statements */
    Conditional statments are use to perform different actions for different decisions
    JS uses the following conditional statements:
        Use `if` to specify a block of code to be executed, if a specified condition is true 
        Use `else` to specify a block of code to be executed, if the same condition is false 
        Use `else if` to specify a new condition to test, if the prior condition is false 
        Use `switch` to specify many alternative blocks of code to be executed 

    - The if Statement
            if (condition) {
                // block of code to be executed if the condition is true 
            }
        Specifies a block of JS code to be executed if a condition is true.
            if (hour < 18) {
                greeting = "Good day";
            }       // Good day 
    
    - The else Statement 
            if (condition) {
                // block of code to be executed if the condition is true 
            } else {
                // block of code to be executed if the condition is false 
            }
        Specifies a block of code to be executed if the condition is false.
            if (hour < 18) {
                greeting = "Good day";
            } else {
                greeting = "Good evening";  
            }       // Good evening 
    
    - The else Statement    
            if (condition1) {
                // block of code to be exectued if conditional is true 
            } else if (condition2) {
                // block of code to be executed if condition1 is false and condition2 is true 
            } else {
                // block of code to be executed if condition1 is false and condition2 is false 
            }
        Specifies a new condition if the first condition is false.
            if (time < 10) {
                greeting = "Good morning";
            } else if {
                greeting = "Good day";
            } else {
                greeting = "Good evening";
            }



/* Logical operators */
    There are three logical operators in JS: `||` (or), `&&` (and), `!` (not)
    Although they are called "logical", they can be applie to values of any type, not only boolean. 
    Their result can also be of any type.

    - || (OR)
        The OR operator is represented with two vertical line symbols 
            result a || b;
        In classical programming, the logical OR is meant to manipulate boolean values only. If any of its arguments are `true`, tis returns `true`, otherwise it returns `false`.
        In JS, the operator is a little bit trickier and more powerful. 

        There are four possible logical combinations:
            alert( true || true );      // true
            alert( false || true );     // true 
            alert( true || false );     // true 
            alert( false || false );    // false 
        As can be seen the result is always `true` except for the case when both operands are `false`.
        If an operand is not boolean, it's converted to a boolean for the evaluation. 
            For instance, the number `1` is treated as `true`, the number `0` as false:
                if (1 || 0) {                   // works just like if( true || false )
                    alert( 'truthy!' ); 
                }
        Most of the time, OR `||` is used in an `if` statement to test if ANY of the given conditions is `true`
            let hour = 9;
            if (hour < 10 || hour > 18) {
                alert( 'The office is closed.' );
            }
        You can "extend", pass multiple conditions, in an OR statment:
            let hour = 12;
            let isWeekend = true;
            if (hour < 10 || hour > 18 || isWeekend) {
                alert( 'The office is close.' );
            }
        The logicals described above are somewhat classical. What follows are the 'extra' features of JS.

    - || (OR) finds the truthy value 
        The extended algorithm works as follows:
            result = value1 || value2 || varlue3;
            The OR `||` operator does the following:
                Evaluates operands from left to right
                For each operand, converts it to boolean. If the result is `true`, stops and returns the original value of that operand.
                If all operands have been evaluated (ie all were `false`), returns the last operand.
        A value is returned in its original form, without the conversion
            In other words, a chain of OR `||` returns the first truthy value or the last one if no truthy value is found.
                alert( 1 || 0 );                    // 1 (1 is truthy)
                alert( null || 1 );                 // 1 (1 is the first truthy value)
                alert( null || 0 || 1 );            // 1 (the first truthy value)
                alert( undefined || null || 0 );    // 0 (all falsy, returns the last value)
            This leads to some interesting usage compared to a "pure, classical, boolean-only OR"
                1) Getting the first turhty value from a list of variables or expressions  
                    For instance, we have `firstName`, `lastName` and `nickName` variables, all optional.
                    Let's use OR || to choose the one that has the data and show it (or `anonymous` if nothing set):
                        let firstName = "";
                        let lastName = "";
                        let nickName = "SuperCoder";
                        alert( firstName || lastName || nickName || "Anonymous" );      // SuperCoder 
                    If all of the variables were falsy, "Anonymous" would show up.
                2) Short-circuit evaluation
                    Another feature of OR || operator is the so-called "short-circuit" evaluation 
                    It means that || processes its arguments until the first truthy value is reached, and then the value is returned immediately, without even touching the other argument. 
                    That importance of this feature becomes obvious if an operand isn't just a value, but an expression with a side effect, such as a variable assignment or a function call. 
                        true || alert("not printed");
                        false || alert("printed");
                            In the above example, only the second message is printed ( "printed" )
                            In the first line, the OR || operator stops the evaluation immediately upon seeing `true`, so the `alert` isn't run. 
                    Sometimes, people use this feature to execute commands only if the condition on the left part is falsy.
    
    - && (AND)
        The AND operator is represented with two ampersands `&&`:
            result = a && b;
        In classical programming, AND returns `true` if both operands are truthy and `false` otherwise:
            alert( true && true );          // true
            alert( false && true );         // false 
            alert( true && false );         // false
            alert( false && false );        // false 
        An example with `if`:
            let hour = 12;
            let minute = 20;
            if (hour == 12 && minute == 30) {
                alert( 'The time is 12:30' );
            }
        Just as with OR, any value is allowed as an operand of AND:
            if (1 && 0) {                                               // evaluated as true && false 
                alert( "won't work, because the result is falsy" );
            }
    
    - AND `&&` finds the first false value 
        Given multiple AND'ed values:
            result = value1 && value 2 && value3;
        The AND `&&` operator does the following:
            Evaluates operands from left to right 
            For each operand, converts it to a boolean. If the result is `false`, stops and returns the origina value of that operand.
            If all operands have been evaluated (ie all were truthy), returns the last operand 
        AND returns the first falsy value or the last value if none were found 
            The rules above are similar to OR. The difference is that AND returns the first falsy value while OR returns the first truthy value. 
                // if the first operand is truthy, AND returns the second operand
                alert( 1 && 0 );        // 0
                alert( 1 && 5 );        // 5

                // if the first operand is falsy, AND returns it. The second operand is ignored
                alert( null && 5 );                 // null 
                alert( 0 && "no matter what" );     // 0

            We can also pass several values in a row, as below. Notice how the first falsy is returned:
                alert( 1 && 2 && null && 3 );       // null
            When all values are truthy, the last value is returned:
                alert( 1 && 2 && 3 );               // 3, the last value 

        Precedence of AND `&&` is higher than OR `||`
            The code `a && b || c && d` is essentially the same as if the `&&` expressions were in parentheses: 
                    `( a && b || c && d )`
        Don't replayce `if` with `||` or `&&`
            Sometimes, people use the AND `&&` operator as a "shorter to write `if`"
                    let x = 1;
                    (x > 0) && alert( 'Greater than zero!' );
                The above expression is analogous to the expression below:
                    let x = 1;
                    if (x > 0) {
                        alert( 'Greater than zero!' );
                    }
            Although the variant with `&&` appears shorter, `if` is more obvious and tends to be a little bit more readable.
            It is recommended to use every construct for its purpose: use `if` if we want if and use `&&` if we want AND.
    
    - ! (NOT)
        The boolean NOT operator is represented with an exclamation sign (!)
            result = !value;
        The operator accepts a single argument and does the following:
            1. Converts the operand to boolean type: `true/false`
            2. Returns the inverse value 
            Example 
                alert( !true );         // false 
                alert( !0 );            // true 
        A double NOT `!!` is sometimes used for converting a value to boolean type
                alert( !!"non-empty string" );  // true 
                alert( !!null );                // false 
            That is, the first NOT converts the value to boolean and returns the inverse, and the second NOT inverses it again. In the end, we have a plain value-to-boolean conversion.
        The built-in `Boolean` fuction is a more verbose way to do the same thing:
            alert( Boolean("non-empty string") );       // true 
            alert( Boolean(null) );                     // false 
        The precendence of NOT `!` is the highest of all logical operators, so it always executes first, before `&&` or `||`

    - Additional Examples 
        alert( null || 2 || undefined );
            // 2 - the first truthy value 

        alert( alert(1) || 2 || alert(3) );
            // first 1, then 2 
                The call to `alert` does not retun a value. In other words, it returns `undefined`
                    1. The first OR `||` evaluates its left operand `alert(1)`. This shows the first message with `1`.
                    2. The `alert` returns `undefined`, so OR goes on to the second operand searching for a truthy value.
                    3. The second operand `2` is truth, so the execution is halted, `2` is returned and then shown by the outer alert.
                There will be no `3`, because the evaluation does not reach `alert(3)`
        
        alert( 1 && null && 2);
            // null - because it's the first falsy value from the list 

        alert( alert(1) && alert(2) );
            // 1, and then undefined 
                The call to `alert` returns `undefined` (it just shows a message, so there's no meaningful return).
                Because of that, `&&` evaluates the left operand (outputs `1`), and immediately stops, because `undefined` is a falsy value. And `&&` looks for a falsy value and returns it, so it's done. 

        alert( null || 2 && 3 || 4 );
            // 3 
                The precedence of AND `&&` is higher than `||`, so it executes first.
                The expression becomes: `null || 3 || 4`
                The result is the first truthy value 
        
        Write an 'if' condition to check that `age` is between `14` and `90` inclusively ("inclusively" means that `age` can reach the edges of `14` and `90`)
            if ( age >= 14 && age <= 90 );
            
        Write an 'if' condition to check that `age` is NOT between `14` and `90` inclusively 
            if ( !( age >= 14 && age <= 90 ) );
                or 
            if ( age < 14 || age > 90 );
        
        Which of the following `alert`s are going to execute and what will the restult be?
            if (-1 || 0) alert( 'first' );                  // executes, result = 'first'       -1 || 0 = -1, truthy
            if (-1 && 0) alert( 'second' );                 // doesn't execute,                 -1 && 0 = 0, falsy  
            if (null || -1 && 1) alert( 'third' );          // executes,                        null || 1 = 1, truthy  

            
        Check the login
            let userName = prompt("Who's there?", '');

            if (userName == "Admin") {

                let password = prompt("Please enter your password", '');
        
                if (password == "TheMaster") {
                    alert( "Welcome!" );
                } else if (password == '' || password == null) {
                    alert( "Cancelled" );
                } else {
                    alert( "Wrong password" );
                }
            
            } else if (userName == '' || userName == null) {
                alert( "Cancelled" );
            } else {
                alert( "I don't know you" );
            }



/* Conditional examples using HTML & JS */

    - Multiple `if() {} else {}` statement for weather
        
        <label for="weather"> Select the weather type today: </label>
        <selet id="weather">
            <option value=""> -- Make a choice -- </option>
            <option value="sunny"> Sunny </option>
            <option value="rainy"> Rainy </option>
            <option value="snowing"> Snowing </option>
            <option value="overcast"> Overcast </option>
        </select>

        <p></p>


        cont select = document.querySelector('select');
        const para - document.querySelector('p');

        select.addEventListener('change', setWeather);

        function setWeather() {
            const choice = select.value;

            if(choice === 'sunny') {
                para.textContent = 'It is nice and sunny outside today. Wear shorts! Got to the beach!';
            } else if (choice === 'rainy') {
                para.textContent = 'Rain is falling outside. Don't forget your raincoat!';
            } else if (choice === 'snowing') {
                para.textContent = 'Snow is falling! Don't forget your hat!';
            } else if (choice === 'overcase') {
                para.textContent = 'It's a glooming day. Bring an umbrella, just in case.';
            } else {
                para.textContent = '';
            }
        }

    - Any value that is not `false`, `undefined`, `null`, `0`, `NaN`, or an empty string ('') actually returns `true` when tested as a conditional statement, therefore you can simply use a variable name on its own to test whether it is `true`, or even that it exists (that is, not undefined).
        
        let cheese = 'Cheddar';

        if (cheese) {
            console.log('Yay! Cheese available for making cheese on toast.');
        } else {
            console.log('No cheese on toast for you today.');
        }

    - Another example where one does not need to explicityly specify '=== true'

        let shoppingDone = false;

        if (shoppingDone) {                 // no need to explicitly specify '=== true'
            let childsAllowance = 10;
        } else {
            let childsAllowance = 5;
        }

    - Nesting if...else statments inside one another 
        
        if (choice === 'sunny') {
            if (temperature < 86) {
                para.textContent = 'It is ' + temperature + ' degrees outside - nice and sunny.';
            } else if (temperature >= 86) {
                para.textContent = 'It is ' + temperature + ' degree outside - REALLY HOT!;
            }
        }

        // Even though the code all works together, each if...else statement works completely independent of each other.

    - You could write the `'sunny' + temperature` code using && (AND)

        if (choice === 'sunny' && temperature is < 86) {
            para.textContent = 'It is ' + temperature + ' degrees outside - nice and sunny.';
        } else if (choice === 'sunny' && temperature is >= 86) {
            para.textContent = 'It is ' + temperature + ' degree outside - REALLY HOT!;
        }

    - A || (OR) conditional

        if (iceCreamTruckOutside || houseStatus === 'on fire') {
            console.log('You should leave the house quickly.');
        } else {
            console.log('Probably should just stay in then.');
        }

    - To write the previous if...else using a != (NOT)

        if (!(iceCreamTruckOutised || houseStatus === 'on fire')) {
            console.log('Probably should just stay in then.');
        } else {
            console.log('You should leave the house quickly.');
            )
        }

    - You can combine as many logical statements together as you want to

        if ((x === 5 || y > 3 || z <= 10) && (loggedIn || userName === 'Steve')) {
            // run the code 
        }

        To make this work you MUST specify a complete test on either side of each OR operator.

    - 



/* switch Statements */ 
    - Good for cases where you want to set a variable to a certain choice of value or print out a particular statement depending on a condition, especially if you've got a large number of choices.
    - Switch statements take a single expression/value as an input, then look through a number of choices until they find one that matches that value, executing the corresponding code that goes along with it.
            switch (expression) {
                case choice1:
                    run this code
                    break;
                
                // include as many cases as you like 

                default:
                    run this code is no cases are met
            }
        1. The keyword `switch`, followed by a set of parentheses.
        2. An expression or value inside the parentheses.
        3. The keyword `case`, followed by a choice that the expression/value could be, followed by a colon.
        4. Some code to run if the choice matches the expression.
        5. A `break` statement, followed by a semi-colon. If the previous choice matches the expression/value, the browser stops exectuing the code block here and moves on to any code that appears below the swith statement.
        6. As many other cases (bullets 3-5) as you like.
        7. The keyword `default`, followed by exactly the same code pattern as one of the cases (bullets 3-5), except that `default` does not have a choice after it, and you don't need to `break` statment as there is nothing to run after this in the block anyway. This is the default option that runs if none of the choices match.
            * You don't have to include the `default` section. you can safely omit it if there is no chance that the expression could end up equaling an unknown value. However, if there is a chance of this, you need to include it to handle unkonwn cases. 
    
        Switch example:
            <label for="weather"> Select the weather type today: </label>
            <select id="weather">
                <option value=""> -- Make a choice -- </option>
                <option value="sunny">Sunny</option>
                <option value="rainy">Rainy</option>
                <option value="snowing">Snowing</option>
                <option value="overcast">Overcast</option>
            </select>

            <p></p>


            const select = document.querySelector('select');
            const para = document.querySelector('p');

            select.addEventListener('change', setWeather);

            fuction setWeather() {
                const choice = select.value;

                switch (choice){
                    case 'sunny':
                        para.textContent = 'It's a sunny day. Let's go to the beach!';
                        break;
                    case 'rainy':
                        para.textContent = 'It's a rainy day. Let's stay on the couch and watch movies!';
                        break;
                    case 'snowing';
                        para.textContent = 'It's snowing! Let's make a snowman!';
                        break;
                    case 'overcast';
                        para.textContent = 'Tut tut. Looks like rain. Don't forget your umbrella!';
                        break;
                    default:
                        para.textContent = '';
                }
            }

    - Using a switch statement in JS
        The following is a working example of a `switch` statement. In this code block, we will find the current day of the week with the `new Date()` method, and `getDay()` to print a number corresponding to the current day. `1` stands for Monday, all the way through `7` which stands for Sunday. We'll start by setting up our variable.
            
            const day = new Date().getDay();

        Using `switch`, we will send a message to the console each day of the week. The program will run in order from top to bottom looking for a match and once one is found, the `break` command will halt the `switch` block from continuing to evaluate statements.

            // Set the current day of the week to a variable, with 1 being Monday and 7 being Sunday 
            const day = new Date().getDay();

            switch (day) {
                case 1:
                    console.log("Happy Monday!");
                    break;
                case 2:
                    console.log("It's Tuesday! You got this!");
                    break;
                case 3:
                    console.log("Hump Day!");
                    break;
                case 4:
                    console.log("Thirsty Thursday! Save me a pint!");
                    break;
                case 5:
                    console.log("TGIF!");
                    break;
                case 6:
                    console.log("Hoy se bebe para hoy es Sabado Gigante!");
                    break;
                case 7:
                    console.log("I need a day off!");
                    break;
                default:
                    console.log("Are we back in quarantine?");
            }

        Depending on the day of the week, your output will be different. We included a `default` block at the end to run in case of an error, which in this case should not happen as there are only 7 days of the week. We could also have only printed results for Monday to Friday and used the `default` block to show the same message through the weekend. 

        * If we had omitted the `break` keyword in each statement, none of the other `case` statements would have evaluated to true, but the proram would have continued to check until it reached the end. In order to make our programs faster and more efficient, we include the `break`.

    - Switch Ranges
        To evaluate a range of values in a `switch` block, set the expression to `true` and do an operation within each `case` statement. 

        To demonstrate, we will make a simple grading app which will take a number score and convert it to a letter grade, with the following requirements:
            Grade of 90 and above = A
            Grade of 80 to 89 = B
            Grade of 70-79 = C 
            Grade 60-69 = D 
            Grade 59 or below = F 

        Now we can write that as a `switch` statement. Since we're checking a range, we will perform the operation in each `case` to check if each expression is evaluating to `true` then break out of the statement once the requirments for `true` have been satisfied.

            // Set the student's grade
            const grade = 87

            switch (true) {
                // If score is 90 or greater 
                case grade >= 90:
                    console.log('A');
                    break;
                // If score is 80 or greater 
                case grade >= 80:
                    console.log('B');
                    break;
                // If score is 70 or greater
                case grade >= 70:
                    console.log('C');
                    break;
                // If score is 60 or greater
                case grade >= 60:
                    console.log('D');
                    break;
                // If score is below 60
                default:
                    console.log('F');
                    break;
            }

        The expression in parentheses to be evaluated is `true` in this example. This means that any `case` that evaluates to `true` will be a match.
        Just like with `else if`, `switch` is evaluated from top to bottom, and the first true match will be accepted. Terefore, even though our `grade` variable is `87` and therefore evaluates to `true` for C and D as well, the first match is B, which will be the output. 

    - Multiple Cases with the same output 
        You may encounter code in which multiple cases should have the same output. In order to accomplish this, you can use more than one case for each block of code.

        This will be shown by creating an application matching the current month to the appropriate season. First, we will use the `new Date()` method to find a number corresponding to the current month, and apply that to the `month` variable. 

            const month = new Date().getMonth();

        The `new Date().getMonth()` method will output a number from 0 to 11, with 0 being January and 11 being December. Our application will then output the four seasons with the following specifications for simplicity:
            Winter: January, February and March
            Spring: April, May and June 
            Summer: July, August and September 
            Fall: October, November and December 

        The following is the code for the season application: 

            // Get number corresponing to the current month, with 0 being January and 11 being December 
            const month = new Date().getMonth();

            switch(month) {
                // January, February, March 
                case 0:
                case 1:
                case 2:
                    console.log('Winter');
                // April, May, June 
                case 3:
                case 4:
                case 5:
                    console.log('Spring');
                // July, August, September 
                case 6:
                case 7:
                case 8:
                    console.log('Summer');
                // October, November, December 
                case 9:
                case 10:
                case 11:
                    console.log('Fall');
                default:
                    console.log('Invalid Month');
            }



/* Ternary operator */
    - The ternary or conditional operator is a small bit of syntax that tests a condition and returns one value/expression if it is `true`, and another if it is `false`. This can be useful in some situations, and can take up a lot less code than an if...else block if you simply have two choices that are chosen between via a `true`/`false` condition. 
            
            ( condition ) ? run this code : run this code instead 

            let greeting = ( isBirthday ) ? 'Happy birthday! We hope you have a great day!' : 'Good morning!'
        
        In the above example, there is a variable `isBirthday`. If `isBirthday` is `true`, we give our guest a happy birthday message; if not, we give her the standard daily greeting. 

    - The following example shows a simple theme chooser where the styling for the site is applied using a ternary operator.
            <label> for="theme">Select theme: </label>
            <select id="theme">
                <option value="white">White</option>
                <option value="black">Black</option>
            </select>

            <h1>This is my website</h1>


            const select = document.querySelector('select');
            const html = document.querySelector('html');
            document.body.style.padding = '10px';

            function update(bgColor, textColor) {
                html.style.backgroundColor = bgColor;
                html.style.color = textColor;
            }

            select.onchange = function() {
                ( select.value === 'black' ) ? update('black', 'white') : update('white', 'black');
            }

        Here we've got a <select> element to choose a theme (black or white), plus a simple <h1> to display a website title. We also have a function called update(), which takes two colors as parameters (inputs). The website's background color is set to the first provided color, and its text color is set to the second provided color. 
        Finally, we've also got an `onchange` event listener that serves to run a function containing a ternary operator. It starts with a test condition - `select.value === 'black'`. If this returns `true`, we run the `update()` function with parameters of black and white, meaning that we end up with background color of black and text color of white. If it returns `false`, we run the `update()` function with parameters of white and black, meaning that the site colors are inverted. 

    - `if...else if... else` ternary operators can be written using the question mark operator (?)
            let age = prompt('age?', 18);

            let message = (age < 3) ? 'Hi, baby!' :
                (age < 18) ? 'Hello!' :
                (age < 100) ? 'Greetings!' :
                'What an unusual age!' ;

            alert( message ); 



/* Active Learning Exercises */
    - Active learning: A simple calendar
            <label for="month">Choose a month: </label>
            <select id="month">
                <option value="january">Enero</option>
                <option value="february">Febrero</option>
                <option value="march">Marzo</option>
                <option value="april">Abril</option>
                <option value="may">Mayo</option>
                <option value="june">Junio</option>
                <option value="july">Julio</option>
                <option value="august">Agosto</option>
                <option value="september">Septembre</option>
                <option value="october">Octubrey</option>
                <option value="november">Noviembre</option>
                <option value="december">Diciembre</option>
            </select>

            <h1></h1>


            const select = document.querySelector('select');
            const list = document.querySelector('ul');
            const h1 = document.querySelector('h1');

            select.onchange =  function() {
                const choice = select.value;
                let days = 31;
                if (choice === 'february') {
                    days = 28;
                } else if (choice === 'april' || choice === 'june' || choice === 'september' || choice === 'november') {
                    days = 30;
                }
            
            createCalendar(days, choice);
            }

            function createCalendar(days, choice){
                list.innerHTML = '';
                h1.textContent = choice;
                for(let i = 1; 1 <= days, i++){
                    const listitem = document.createElement('li');
                    listitem.textContent = i;
                    list.appendChild(listitem);
                }
            }

            
    - Active learning: Color choices 
            <label for="theme">Choose a theme: </label>
                <select id="theme">
                    <option value="white">White</option>
                    <option value="black">Black</option>
                    <option value="purple">Purple</option>
                    <option value="yellow">Yellow</option>
                    <option value="psychedelic">Psychedelic</option>
                </select>

            <h1>This is my website</h1>

            const choice = querySelector('select');
            const html = querySelector('html');
            document.body.style.padding = '10px';

            select.onchange = function() {
                const choice = select.value;

                switch(choice){
                    case 'white':
                        update('white','black');
                        break;
                    case 'black':
                        update('black','white');
                        break;
                    case 'purple':
                        update('purple','white');
                        break;
                    case 'yellow':
                        update('yellow','darkgray');
                        break;
                    case 'psychedelic':
                        update('lime','purple');
                        break;
                }
            }

            function update(bgColor, textColor) {
                html.style.backgroundColor = bgColor;
                html.style.color = textColor;
            }
            


/* JS Functions */
    - Built-in Functions    
        // the replace() string function takes a source string, and a target string and replaces the source string, with the target string, and returns the newly formed string 
                let myText = 'I am a string';
                let newString = myText.replace('string', 'sausage');        // replaces the word 'string' with 'sausage'
                consol.log(newString);

        // the join() function takes an array, joins all the array items together into a single string, and returns this new string 
                let myArray = ['I', 'love', 'chocolate', 'frogs'];
                let madeAString = myArray.join(' ');                        // joins all of the strings to a single string 
                console.log(madeAString);

        // the random() function generates a random number between 0 and up to but not including 1, and returns that number 
                let myNumber = Math.random();

        The JavaScript language has many built-in functions to allow you to do usefull things without having to write all that code yourself. In fact, some of the code you are calling when you invoke a built in browser function couldn't be written in JavaScript - many of these functions are calling parts of the background browser code, which is written largely in low-level system languages like c++, not web languages like JavaScript.

        Bear in mind that some built-in browser functions are not part of the core JavaScript language - some are defined as part of browser APIs, which build on top of the default language to provide even more functionality 
            (https://developer.mozilla.org/en-US/Learn/JavaScript/First_steps/What_is_JavaScript#So_what_can_it_really_do)

    - Functions versus methods 
        Programmers call functions that are part of objects methods. 
            The built-in code we've made use of so far camein both forms: functions and methods. You can check a full list of the built-in functions, as well as the built-in objects and their corresponding methods (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects)

            You've also seen a lot of custom functions in the course so far - functions defined in your code, not inside the browser. Anytime you saw a custom name with parentheses straight after it, you were using a custom fucntion. 

            Functions can contain whatever code you like - you can even call other functions from inside functions.

    - Invoking functions
        In order to use a function after it has been defined, you've got to run, or invoke, it. This is done by including the name of the function in the code somewhere, followed by parentheses.

                function myFunction() {
                    alert('hello');
                }

                myFunction();               // calls the function once 
        
    - Anonymous functions 
        You may see functions defined and invoked in slightly different ways.

        Functions can have names
                function myFunction() {
                    alert('hello');
                }

        Functions can be anonymous (NOT have names)
                function() {
                    alert('hello');
                }

            Anonymous functions won't do anything on their own. You generally use an anonymous function along with an event handler, for example the following would run the code inside the function whenever the associated button is clicked:

                const myButton = document.querySelector('button');

                myButton.onclick = function() {
                    alert('hello');
                }

            The above example would require there to be a <button> element available on the page to select and click. 

        An anonymous function can be assigned to the value of a variable:

                const myGreeting = function() {
                    alert('hello');
                }
        
            The function can now be invoked using:      myGreeting();
                This effectively gives the function a name.
            
        You can also assign the function to be the value of multiple variables: 

            let anotherGreeting = myGreeting;

        This function can now be invoked using either of:

            myGreeting();
            anotherGreeting();

        But this would be confusing so we don't do it. It is better to just stick to this form:

            function myGreeting() {
                alert('hello');
            }

        You will mainly use anonymous functions to just run a load of code in response to an event firing - like a button being click - using an event handler. Again, this looks something like this: 

            myButton.onclick = function() {
                alert('hello');
                // I can put as much code inside here as I want 
            }

    - Function parameters
        Some functions require parameters to be specified when you are invoking them - these are values that need to be included inside the function parentheses, which it needs to do its job properly. Parameters are sometimes called arguments, properties, or even attributes.

        As an example, the broswer's built-in `Math.random()` function doesn't require any parameters

            let myNumber = Math.random();

        The browser's built-in string `replace()` function however needs two parameters - the substring to find in the main string, and the substring to replace that sting with:

            let myText = 'I am a string';
            let newSting = myText.replace('string', 'sausage');

        It should also be noted that sometiems paraters are optional. If you don't, the function will generally adopt some kind of default behavior. As an example, the array `join()` function's parameter is optional:

            let myArray = ['I', 'love', 'chocolate', 'frogs'];

            let madeAString = myArray.join(' ');
            //returns 'I love chocolate frogs'

            let madeAString = myArray.join();
            // returns 'I, love, chocolate, frogs'

        If no parameter is included to specify a joining/delimiting character, a comma is used by default. 

    - Function scope and conflicts
        When you create a function, the variables and other things defined inside the function are inside their own separate scope, meaning that they are locked away in their own separate compartments, unreachalbe from code outside the functions. 

        The top level outside all your functions is called GLOBAL SCOPE. Values defined in the global scope are accessible from everywhere in the code. 

        JavaScript is set up like this for various reasons - but mainly because of security and organization. Sometimes you don't want variables to be accessible from everywhere in the code - external scripts that you call in from elsewhere could start to mess with your code and cause problems because they happen to be using the same variable names as other parts of the code, causing conflicts. This might be done maliciously, or just by accident. 

        Say you hvae an HTML file that is calling in two external JavaScript files, and both of them have a variable and a function defined that use the same name: 

            <!-- Excerpt from my HTML -->
            <script src="first.js"></script>
            <script src="second.js"></script>
            <script>
                greeting();
            </script>

            // first.js
            let name = 'Chris";
            function greeting() {
                alert('Hello' + name + ': welcome to our company.');
            }
        
            // second.js 
            let name = 'Zaptec';
            function greeting() {
                alert('Our company is called ' + name + '.');
            }

        Both functions you want to call are called `greeting()`, but you can only ever access the `first.js` file's `greeting()` function (the second one is ignored). In addition, attempting to declare the `name` variable a second time with the `let` keyword in the `second.js` file results in an error.

        Keeping parts of your code locked away in functions avoids such proglems, and is considereed the best practice. 
            If code were a zoo, each animal habitat would be a function and the zoo keep is like the global scope - they have the keys to access every enclosure.

        * The same scoping rules do not apply to loop (eg `for() {...}`) and conditional blocks (eg `if() {...}`) - they look very similar, but they are not the same thing. 

        * The 'ReferenceError: "x" is not defined' error is ONE OF THE MOST COMMON you'll encounter. If you get this error and you are sure that you have defined the variable in question, check what scope it is in. 
        
    - Functions inside functions 
        Keep in mind that you can call a function from anywhere, even inside another function. This is often used as a way to keep code tidy - if you have a big comples function, it is easier to understand if you break it down into several sub-functions:

                function.myBigFunction() {
                    let myValue;

                    subFunction1();
                    subFunction2();
                    subFunction3();
                }

                function subFunction1() {
                    console.log(myValue);
                }

                function subFunction2() {
                    console.log(myValue);
                }

                function subFunction3() {
                    console.log(myValue);
                }

        Just make sure that the values being used inside the function are properly in scope. The example above would throw an error `ReferenceError: myValue is not defined`, because although the `myValue` variable is defined in the same scope as the function calls, it is not defined inside the function definitions - the actual code that is run when the functions are called. To make this work, you'd have to pass the value into the function as a parameter, like this: 

                function.myBigFunction() {
                    let myValue;

                    subFunction1(myValue);                  // The `subFunction()` take in `myValue` 
                    subFunction2(myValue);
                    subFunction3(myValue);
                }

                function subFunction1(value) {              // They then assign `myValue` to `value` and 
                    console.log(value);                     // pass `value` to the `console.log()`
                }

                function subFunction2(value) {
                    console.log(value);
                }

                function subFunction3(value) {
                    console.log(value);
                }

    - Build your own function:

        <body>
        <button>Display message box</button>

        <script>

        function displayMessage(msgText, msgType) {
            const html = document.querySelector('html');
                /* Used to select an HTML element and store a reference to it in a constant. This allows us to maipulate it later on. */



            const panel = document.createElement('div');
                /* Used to create an HTML element and store a reference to it in a constant. */
            panel.setAttribute('class', 'msgBox');
                /* Used to set a `class` attribute to the panel with a value of `msgBox`. This is to make it easier to style the element with pre-written CSS. */
            html.appendChild(panel);
                /* DOM function used to nest one element inside the other as a child of it. 'panel' is the variable name of the element that will be appended. 'html' is the element that will become the parent. If skipped, the element we created won't appear on the page on its own. */



            const msg = document.createElement('p');
                /* Creates a new 'p' element. */
            msg.textContent= msgText;
                /* Used to insert a message inside of the new 'p' <element>: 'msg' */
            panel.appendChild(msg);
                /* Appends the new 'p' to the 'panel' */



            const closeBtn = document.createElement('button');
                /* Creates a new 'p' element. */
            closeBtn.textContent = 'x';
                /* Used to insert a message inside of the new 'button' <element>: 'closeBtn' */
            panel.appendChild(closeBtn);
                /* Appends the new 'button' to the 'panel' */



            closeBtn.onclick = function() {
                /* Makes it so that when a button is clicked, some code is run to delete the whole panel from the page - to close the message box. Made equal to any anonymous function, which contains the code to run when the button is clicked. */

                panel.parentNode.removeChild(panel);
                    /* Removes a specific child element of the HTML element - in this case the panel <div> */
            }

            if (msgType === 'warning') {
                msg.style.backgroundImage = 'url(icons/warning.png)';
                panel.style.backgroundColor = 'red';
            } else if (msgType === 'chat') {
                msg.style.backgroundImage = 'url(icons/chat.png)';
                panel.style.backgroundColor = 'aqua';
            } else {
                msg.style.paddingLeft = '20px';
            }



            /* This whole block of code generates a block of HTML that looks like the following, and then inserts it into the page:
            
                <div class="msgBox">
                    <p>This is a message box</p>
                    <buttong>x</button>
                </div>
            
            */
        }

        const btn = document.querySelector('button');
            /* Stores a reference to the 'button' */
        btn.onclick = function(){
            displayMessage('Your inbox is almost full  delete some mails', 'warning');
        };
            /* Similar to `closeBtn.onclick...`, calls some code in response to the button being clicked. BUT instead of calling an anonymous function containing some code, we are calling our function name directly. */

                /* If the parentheses are included after the function name, the function will be called immediately instead of when the button is clicked.  */

        </script>
    </body>

    - Function return values:

        Return values are the values that a function returns when it has completed. It is very useful to know and understand what values are returned by functions, so we try to include this information wherever possible. 

        Some functions don't retun any value. In these cases, our reference pages list the return value as `void` or `undefined`.

        Generally, a return value is used where the function is an intermediate step in a calculation of some kind. 

        Return values can be stored in a variable and used in future calculations. 
            
            To return a value from a custom function, you need to use the `return` keyword.

        * It is generally a good idea to check that any necessary parameters are validated, and that any optional parameters have some kind of default value provided. This way, you program will be less likely to throw errors.

        * As you go further into your programming career, you'll start doing the same kinds of things over and over again. It is a good idea to create your own library of utility functions dto do these sorts of things.

        It is possible to use `return` without a value. That causes the function to exit immediately.

            function showMovie(age) {
                if ( !checkAge(age) ) {
                    return;
                }
                alert( "showing you the movie" ); 
                // ...
            }

            // If `checkAge(age)` returns `false`, then `showMovie` won't proceed to the `alert`.

        A function with an empty `return` or without it returns `undefined`:

            function doNothing() { /* empty */ }
            
            alert( doNothing() === undefined );     // true

        An empty `return` is also the same as `return undefined`:
            function dNothing() {
                return;
            }
        
            alert( doNothing() === undefined );     // true

        * Never add a newline between `return` and the value. JS assumes a semicolon after `return`, so if you add a newline it effectively makes it an empty return. If you must use a newline, wrap the return in parentheses. 

    - Function naming
        
        Functions are actions so their names are usually verbs. It is widespread practice to start a function with a verbal prefix which vaguely describes the action:

                "show..." - shows something
                "get..." - return a value 
                "calc..." - calculate something 
                "create..." - create something 
                "check..." - check something and return a boolean 

    - One function = one action 

        A function should do exactly what is suggest by its name, no more. 

        Two independedn actions usually deserve two functions, even if they are usually called together (in that case we can make a 3rd function that calls those two).

        * Separate functions are easier to test and debug 

    - Function Expressions 

            let sayHi = function() {
                alert( "Hello" );
            };

        The function is created and assigned to the variable explicitly, like any other value. No matter how the function is defined, it's just a value stored in the variable `sayHi`.

        In JS, a function is a value, so we can deal with it as a value. Because functions are also values, they can be copied to another variable:
    
            function sayHi() {      // create - declares function and puts it in a varialbe named `sayHi`
                alert( "Helo" );
            }

            let func = sayHi;       // copy - copies `sayHi` to variable `func` 
                                    // note no parentheses after `sayHi` - if there were, this would write the result of the call `sayHi()` into `func`, not the function `sayHi` itself 

            funct();                // run the copy - now the function can be called as `funct()` and as `sayHi()`
            sayHi();                // run the original

        * The same code can be written as follows, using a Function Expression:

            let sayHi = function() {
                alert( "Hello" );
            };

            let func = sayHi;

        * Why is there a semicolon at the end?

            There is no need for a ; at the end of code blocks and syntax structures that use them like `if{...}`, `for {}`, `function f {}`, etc

            A Function Expression is used inside the statement: `let sayHi = ...;`, as a value. It's not a code block, but rather an assignment. The semicolon ; is recommended at the end of statements, no matter what the value is. So the semicolon here is not related to the Function Expression itself, it just terminates the statement. 

    - Callback functions 

        A function is passed as a variable and can be "called back" later if necessary.

            function ask(question, yes, no) {
                if (confirm(question)) yes()
                else no();
            }
        
            function showOk() {
                alert( "You agree." );
            }

            function showCancel() {
                alert( "You canceled the execution." );
            }

            // usage: functions showOk, showCancel are passed as arguments to ask
            ask("Do you agree?", showOk, showCancel);

        The arguments `showOk` and `showCancel` of `ask` are called 'callback functions' or just 'callbacks'. In the case above, `showOk` becomes the callback for "yes", and `showCancel` for "no". 

        The same function can be writting much shorter with Funciton Expressions:

            function ask(question, yes, no) {
                if (confirm(question)) yes()
                else no();
            }

            ask(
                "Do you agree?",
                function() { alert("You agreed."); },
                function() { alert("You canceled the execution."); }
            );

        Above, functions are declared right inside the `ask(...)` call. They have no name, and so are called anonymous. Such functions are not accessible outside of `ask` (because they are not assigned to variables), but that's just what we want here. 

        * A function is a value representing an "action". Regular values like strings or numbers represent the data. A function can be perceived as an action. We can pass it between variables and run when we want. 

    - Function Expression vs Function Declaration 

        Let's formulate the key differennces between Declarations and Expressions:

            1) Syntax: how to differentiate between them in the code.

                Function Declaration: a function, declared as a separate statement, in the main code flow

                    function sum(a, b) {
                        return a + b;
                    }

                Function Expression: a function, created inside an expression or inside another syntax construct. Here, the function is created at the right of the "assignment expression"

                    let sum = function(a, b) {
                        return a + b;
                    };

            2) When a function is created 

                A Function Expression is created when the execution nreaches it and is usable only from that moment. Once the execution flow passes to the right of the assignment `let sum = function`, the function is created and can be used (assigned, called, etc).

                A Function Declaration can be called earlier than it is defined. Example, a global Function Declaration is visible in the whole script, no matter where it is. This is due to internal algorithms. When JS prepares to run the script, it first looks for global Function Declarations in nit and creates the functions. We can think of it as an "initialization stage". After all the Function Declarations are processed, the code is executed. 

            3) Function scope    
                
                Function Declarations have "block scope". In In strict mode, when a Function Declaration is within a code block, it's visible everywhere inside that block. But not outside of it. 

        When to choose Function Declaration versus Function Expression?

            1) Function Declaration syntax - It give more freedom in how to organize our code, because we can call such functions before they are declared. It is easier to look up `function f(...) {...}` in the code than `let f = function(...) {...};`.

            2) If a Function Declaration does not suit us or we need a conditional declaration, then Function Expression should be used. 

    - Arrow Functions, the basics:

        Arrow functions are another very simple and concise syntax for creating functions, often better than Function Expressions.

            let func = (arg1, arg2, ...argN) => expression 

        This creates a function `func` that accepts arguments `arg1...argN`, then nevaluates the `expression` on the right side with their use and returns its result. It's the shorter version of: 

            let funnc = function(arg1, arg2, ...argN) {
                return expression;
            };

        The following is a concrete example of an arrow function:

            let sum = (a, b) => a + b;

            alert( sum(1, 2) );         // 3

        If you only have one argument, then the parentheses around the parameters can be omitted:

            let double = n => n * 2;
            
            alert( double(3) );         // 6

        If ther eare no arguments, parentheses will be empty (but they should be present):

            let sayHi = () => alert("Hello!");

            sayHi();

        Arrow functions can be used in the same way as Function Expressions. For example, to dynamically create a function:

            let age = prompt("What is your age?", 18);

            let welcome = (age < 18) ?
                () => alert('Hello') :
                () => alert("Greetings!");

            welcome();

    - Multilinen arrow functions 

        let sum = (a, b) => {           // the curly brace opens a multiline function 
            let result = a + b;
            return result;              // if we use curly braces, then we need an explicit "return"
        }

        alert( sum(1, 2) );             // 3

        

/* JS Arrays */
    - Arrays are built like so:

            let arrayName = [<element1>, <element2>, ..., <elementN>]
        
        Spaces and lin breaks are not important. A declaration cann span multiple lines.

    - Array access 

        Arrays are accessed by referring to the index number:

            let varName = arrayName[x];

        The first item in the array is of index number 0 [0], the second [1], the third [2], and so on.

            let first = arrayName[0];
            let second = arrayName[1];

                or

            document.getElementById("demo").innerHTML = arrayName[0];

        To access the full array, refer to the array name:

            document.getElementById('demo')innerHTML = arrayName;

    - Arrays are objects

        The `typeOf` operator in JS returns "object" for arrays, but JS arrays are best described as arrays. 

        Arrays use numbers to access its 'elements': arrayName[0]

        Objects use names to access their "members". In the example below, `person.firstName` return John:

            let person = {firstName:"John", lastName: "Doe", age: 46};

    - Array elements can be objects

        JS variables can be objects. Arrays are special kinds of objects. Because of this, you can have variables of different types in nthe same Array.

            myArray[0] = Date.now;
            myArray[1] = myFunction;
            myArray[2] = myCars;

    - Array properties and methods

        The real strength of JS arrays are the built-in array properties and methods:

            let x = cars.length;    // The length property retuns the number of elements
            let y = cars.sort();    // The sort() method sorts arrays 

        The `length` property of an array returns the length of an array (the number of array elements).

            let fruits = ["Banana", "Orange", "Apple", "Mango"];
            fruits.length;      // the length of fruits is 4

        To access the first array element:

            let first = fruits[0];

        To access the last array element:

            let last = fruits[ fruits.length - 1 ];

    - Looping an array 

        The safest way to loop through an array, is using a `for` loop:

            let fruit, text, fLen, i;
            let fruits = ["Banana", "Orange", "Apple", "Mango"];    
            fLen = fruits.length;

            text = "<ul>";
                for (i = 0; i < fLen; i++) {
                    text += "<li>" + fruits[i] + "</li>";
                }
            text += "</ul>";

        You can also use the `Array.forEach()` function:

            let fruit, text;
            let fruits = ["Banana", "Orange", "Apple", "Mango"];    

            text = "<ul>";
                fruits.forEach(myFunction);
            text += "</ul>";

            function myFunction(value) {
                text += "<li>" + value + "</li>";
            }
        
    - Adding array elements

        The easiest way to add a new element is to use the `push()` method

            let fruits = ["Banana", "Orange", "Apple", "Mango"];
            fruits.push("Lemon");    // adds a new element (Lemon) to fruits

        You can also use the `length` property:

            let fruits = ["Banana", "Orange", "Apple", "Mango"];
            fruits[fruits.length] = "Lemon";    // adds a new element (Lemon) to fruits

    - Associative arrays 

        Many languages support arrays with named indexes. These are called associative arrays (or hashes). JS does NOT support arrays with named indexes.

                var person = [];
                person[0] = "John";
                person[1] = "Doe";
                person[2] = 46;
                var x = person.length;     // person.length will return 3
                var y = person[0];         // person[0] will return "John"

        In JS, arrays ALWAYS use numbered indexes.

            * If you use named indexes, JS will redefine the array to a standard object. After that, some array methods and properties will produce incorrect results.

                var person = [];
                person["firstName"] = "John";
                person["lastName"] = "Doe";
                person["age"] = 46;
                var x = person.length;     // person.length will return 0
                var y = person[0];         // person[0] will return undefined

    - The difference between arrays and objects 

        In JS, arrays use numbered indexes.

        In JS, objects use named indexes.

            * Arrays are a special kind of object, with numbered indexing. 

    - When to use arrays. When to use objects.

        Avoid `new Array()`

            There is no need to use the JS built-in array constructor `new` Array().

            Instead use []

                var points = new Array();     // Bad
                var points = [];              // Good 
            
            The `new` keyword only complicates the code. It can also produce unexpected results. 

    - How to deteremine if it's an array 

        Array.isArray( arrayName );   // returns true
                                      // not supported in older browsers 

            or

        function isArray(x) {
            return x.constructor.toString().indexOf("Array") > -1;
        }           // Always returns true if the object prototype contains the word "Array"

            or

        arrayName instanceof Array;   // returns true if an object is created by a given constructor 
        
    - JS Array Methods 

        Use `toString()` to convert an array to a string of (comma separated) array values.

            let fruits = ["Banana", "Orange", "Apple", "Mango"];
            document.getElementById("demo").innerHTML = fruits.toString();

        Use `join()` to join all array elements into a string. It behaves just like `toString()`, but also allows you to specify the separator:

            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            document.getElementById("demo").innerHTML = fruits.join(" * ");

        Use `pop()` to remove the last element from an array:

            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            fruits.pop();      // Removes the last element ("Mango") from fruits

            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            var x = fruits.pop();      // the value of x is "Mango"

        Use `push()` to add a new element to an array (at the end):

            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            fruits.push("Kiwi");       //  Adds a new element ("Kiwi") to fruits

        The `push()` method returns the new array length:

            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            var x = fruits.push("Kiwi");   //  the value of x is 5
    
        Use `shift()` to remove the first array element and "shift" all other elements to a lower index:

            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            fruits.shift();            // Removes the first element "Banana" from fruits

        The `shift()` method returns the string that was "shifted out":

            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            var x = fruits.shift();    // the value of x is "Banana"

        Use `unshift()` to add a new element to an array (at the beginning), and "unshift" older elements:

            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            fruits.unshift("Lemon");    // Adds a new element "Lemon" to fruits

        The `unshift()` method returns the new array length:

            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            fruits.unshift("Lemon");    // Returns 5

        Use `length` to append a new element to an array:

            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            fruits[fruits.length] = "Kiwi";          // Appends "Kiwi" to fruits

        Use `delete` to delete an element from an array:

            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            delete fruits[0];           // Changes the first element in fruits to undefined

        * Using `delete` may leave undefined holes in the array. You should use `pop()` or `shift()` instead.

        Use `splice()` to add new items to an array:

            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            fruits.splice(2, 0, "Lemon", "Kiwi");

                The first parameter (2) defines the position where new elelements should be added (spliced in). The second parameter (0) defines how many elements should be removed).
                The rest of the parameters ("Lemon", "Kiwi") define the new elemennts to be added.

        The `splice()` method returns an array with the deleted items: 

            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            fruits.splice(2, 2, "Lemon", "Kiwi");

        You can use `splice()` to remove elements without leaving "holes" in the array:

            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            fruits.splice(0, 1);        // Removes the first element of fruits

                The first parameter (0) defines the position where new elements should be added (spliced in). The second parameter (1) defines how many elemennts should be removed. The rest of the parameters are omitted. No new elemennts will be added. 

        Use `concat()` to create a new array by merging (concatenating) existing arrays:

            var myGirls = ["Cecilie", "Lone"];
            var myBoys = ["Emil", "Tobias", "Linus"];
            var myChildren = myGirls.concat(myBoys);   // Concatenates (joins) myGirls and myBoys

                * The `concat()` method does not change the existing arrays. It always returns a new array.

        The `concat()` method can take any number of array arguments:

            var arr1 = ["Cecilie", "Lone"];
            var arr2 = ["Emil", "Tobias", "Linus"];
            var arr3 = ["Robin", "Morgan"];
            var myChildren = arr1.concat(arr2, arr3);   // Concatenates arr1 with arr2 and arr3

        The `concat()` method can also take strings as arguments:

            var arr1 = ["Emil", "Tobias", "Linus"];
            var myChildren = arr1.concat("Peter"); 

        Use `slice()` to cut out a piece of an array into a new array:

            var fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
            var citrus = fruits.slice(1);
            // slices out a part of an array starting from element 1 ("Orange")

                * The `slice()` method creates a new array. It does not remove any elements from the source array.

            var fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
            var citrus = fruits.slice(3);
            // this example slices out a part of an array starting from array element 3 ("Apple")
        
        `slice()` can take two arguments like `slice(1, 3)`. The method then selects elements from the start argument, and up to (but not including) the end argument.

            var fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
            var citrus = fruits.slice(1, 3);

        If the end argument is omitted, like in the first examples, the `slice()` method slices out the rest of the array.

            var fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
            var citrus = fruits.slice(2);

        JS automatically converts an array to a comma separated string when a primitive value is expected. This is always the case when you try to output an array. The following to examples produce the same result:

            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            document.getElementById("demo").innerHTML = fruits.toString();

            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            document.getElementById("demo").innerHTML = fruits;

        * All JS objects have a `toString()` method.

        There are no built-in functions for finding the highest or lowest value in a JS array. 

    - The spread operator (...)

        Useful and quick syntax for adding items to arrays, combining arrays or objects, and spreading an array out into a function's arguments.

        When `...arr` is used in the funtion call, it 'expands' an iterable object `arr` into the list of arguments.

        Trying to pass an array [x, y, z] to a JS funnction expecting separat arguments does not work. The spread syntax "spreads" the array into separate arguments.

        Also useful for:
            copying an array
            concatenating or combining arrays
            using Math functions
            using an array as arguments
            adding an item to a list
            adding to state in React
            combining objects 
            converting NodeList to an array 

        Can also be used on a string.

    - Rest parameters???



/* JS Loops */

    - The `for` loop

            for (initializer; condition; final-expression) {
                // code to run
            }

        Example of a `for` loop in action:

            const cats = ['Bill', 'Jeff', 'Pete', 'Biggles', 'Jasmin'];
            let info = 'My cats are called ';
            const para = document.querySelector('p');

            for (let i = 0; i < cats.length; i++) {
                info += cats[i] + ', ';
            }

            para.textContent = info;

        This loop is used to iterate over the items in an array and do something with each of them:

            1. The counter variable (sometimes known as an initializer or an iteration variable), i, starts at 0 

            2. The loop has been told to run until i is no longer smaller than the length of the `cats` array.

            3. Inside the loop, we concatenate the current loop item (cats[i], which is cats[whatever i is at the time]) along with a comma and space, onto the end of the `info` variable

            4. When i becomes equal to cats.length, the loop will stop, and the broswer will move on to the next bit of code below the loop.

        To make the final output sentance more well-informed:

            for (let i = 0; i < cats.length; i++) {
                if (i === cats.length - 1) {
                    info += 'and ' + cats[i] + '.';
                } else {
                    info += cats[i] + ', ';
                }
            }

        * With any for loop, be sure to increment or decrement the initializer or the for loop will run infinitely. 

    - Exiting loops with break 

        If you want to exit a loop beofre all the iterationns have been completed, you can use the break statement. A break statement will immediately exit the loop and make the browser move on to any code that follows it. 

        To search for a contact name using HTML and JS:

            First, lets set up the HTML: a text <input> will allow us to enter a name to search for, a <button> element will submit the search, and a <p> element to display the results in: 

                <label for="search">Search by contact name: </label>
                <input id="search" type="text">
                <button>Search</button>

                <p></p>

            Now for the JavaScript:

                const contacts = ['Chris:2232322', 'Sarah:3453456', 'Bill:7654322', 'Mary:9998769', 'Dianne:9384975'];
                const para = document.querySelector('p');
                const input = document.querySelector('input');
                const btn = document.querySelector('button');

                btn.addEventListener('click', function() {
                let searchName = input.value.toLowerCase();
                input.value = '';
                input.focus();
                for (let i = 0; i < contacts.length; i++) {
                    let splitContact = contacts[i].split(':');
                    if (splitContact[0].toLowerCase() === searchName) {
                    para.textContent = splitContact[0] + '\'s number is ' + splitContact[1] + '.';
                    break;
                    } else {
                    para.textContent = 'Contact not found.';
                    }
                }
                });

                    1. First we have some variable definitions - we have an array of contact information, with each item being a string containing a name and phone number separated by a colon.

                    2. Next, we attach an event listener to the button (btn), so that when nit is pressed, some code is fun to perform the search and return the results.

                    3. We store the value entered into the text input in a variable called `searchName`, before then emptying the text input and focusing it again, ready for the nnext search. Note that we also run the `toLowerCase()` method on the string, so that searches will be case-insensitive. 

                    4. For the loop,

                        4a. We start the counter at 0, run the loop until the counter is no longer less than `contacts.length` and increment i by 1 after each iteration of the loop. 

                        4b. Inside the loop, we first split the current contact (contacts[i]) at the colon character, and store the resulting two values in an array called `splitContact`

                        4c. We then nuse a conditional statement to test whether `splitContact[0]`(the contact's name, again lower-cased with `toLowerCase()`) is equal to the inputted `searchName`. If it is, we enter a string into the paragraph to report what the contact's number is, and use `break` to end the loop. 

                    5. After `(contacts.length-1)` iterations, if the contact name does not match the entered search the paragraph text is set to "Contact not found.", and the loop continues looping until the condition is no longer true. 

    - Skipping iterations with continue 

        The continue statement works in a similar manner to `break`, but instead of breaking out of the loop entirely, it skips to the next iteration of the loop. The following example takes a number as an input and returns only the numbers that are squares of integers (whole numbers).

                The HTML is basically the same as the last example - a simple text input, and a paragraph for output. The JS is mostly the same too, although the loop itself is a bit different.

            let num = input.value;

            for (let i = 1; i <= num; i++) {
            let sqRoot = Math.sqrt(i);
            if (Math.floor(sqRoot) !== sqRoot) {
                continue;
            }

            para.textContent += i + ' ';
            }

                1. In this case, the input should be a number(num). The `for` loop is given a counter starting at 1 (as we are not interested in 0 in this case), an exit condition that says the loop will stop when the counter becomes bigger than the input `num`, and an iterator that adds 1 to the counter each time. 

                2. Inside the loop, we find the squre root of each number using Math.sqrt(i), then check whether the square root is an integer by testing whether it is the same as itself when it has been rounded down to the nearest integer (this is what Math.floor() does to the number it is passed). 

                3. if the square root and the rounded dow nsquare root do not equal one another (!==), it means that he square root is not an integer, so we are not interested in it. In such a case, we use the `continue` statement to skip on to the next loop iteration without recording the number anywhere.

                4. If the square root is an integer, we skip past the if block entirely so the `continue` statement is no executed; instead, we concatenate the current i value plus a space on to the end of the paragraph content. 
    
    - The `while` loop

            initializer
            while (condition) {
            // code to run

            final-expression
            }

        This works in a very similar way to the `for` loop, exept that the initializer variable is set before the loop, and the final-expression is included inside the loop after the code to run - rather than these two items being included inside the parentheses. The condition is included inside the parentheses, which are preceded by the `while` keyword rather than `for`.

        The same three items are still present, as they are still defined in the same order as they are in the `for` loop - this makes sense, as you still have to have an initializer defined before you can check whether it has reached the point where the condition is no longer true; the final-expression is then run after the code inside the loop has run (an iteration has been completed), which will only happen if the condition is still true. 

            let i = 0;

            while (i < cats.length) {
                if (i === cats.length - 1) {
                    info += 'and ' + cats[i] + '.';
                } else {
                    info += cats[i] + ', ';
                }

                i++;
            }

    - The `do...while` loop

        The do...while loop is very similar, but provides a variation on the while structure:

            initializer
            do {
                // code to run

                final-expression
            } while (condition)

        In this case, the initializer again comes frist, before the loop starts. The keyword directly precedes the curly braces containing the code to run and the final expression. 

        The differentiator here is that the condition comes after everything else, wrapped in parentheses and preceded by a `while` keyword. Inn a `do...while` loop, the code inside the curly braces is always run once before the check is made to see if it should be executed again (in while and for, the check comes first, so the code might never be executed).

        This is the cat listing example using a `do...while` loop:

            let i = 0;

            do {
                if (i === cats.length - 1) {
                    info += 'and ' + cats[i] + '.';
                } else {
                    info += cats[i] + ', ';
                }

                i++;
            } while (i < cats.length);

        

/* CSS Attribute Selectors */

    The CSS attribute selector matches elements based onn the presennce or value of a given attribute.

        /* <a> elements with a title attribute */

        a[title] {
            color:purple
        }

        /* <a> elements with an href matching 'https://example.org' */
        a[href="https://example.org'] {
            color: green;
        }

        /* <a> elements with an href containing "example" */
        a[href*="example"] {
            font-size: 2rem;
        }

        /* <a> elements with an href ennding ".org" */
        a[href$=".org"] {
            font-style: italic;
        }

    The following is a list of operators that can be used onn various attributes, some taking a value and some not taking a value:

        [attr] - Represents elements with ann attribute name of attr 

        [attr = value] - Represents elements with an attribute name of `attr` whose value is exactly `value`.

        [attr ~= value] - Represents elements with an attribute name of `attr` whose value is a whitespace-separated list of words, one of which is exactly `value`. 

        [attr |= value] - Represents elements with an attribute name of attr whose value can be exactly value or can begin with value immediately followed by a hyphen, - (U+002D). It is often used for language subcode matches.

        [attr ^= value] - Represents elements with an attribute name of attr whose value is prefixed (preceded) by value.

        [attr $= value] - Represents elements with an attribute name of attr whose value is suffixed (followed) by value.

        [attr *= value] - Represents elements with an attribute name of attr whose value contains at least one occurrence of value within the string.

        [attr operator value i] - Adding an i (or I) before the closing bracket causes the value to be compared case-insensitively (for characters within the ASCII range).

        [attr operator value s] - Adding an s (or S) before the closing bracket causes the value to be compared case-sensitively (for characters within the ASCII range).

        
        
/* JS Transitionend Events */

    The `transitionend` even is fired whe na CSS transition has completed. In the case where transition is removed before completion, such as if the `transition-property` is removed or `display` is set to `none`, then the even will not be generated. 

    The `transitionend` even is fired in both directions - as it finishes transitioning to the transitioned state, and when it fully reverts to the default or non-transitioned state. If there is no transition delay or duration, if both are 0s or neither is declared, there is no transition, and none of the transition events are fired. If the `transitioncancel` event is fired, the `transitionend` event will not fire.

    The original target for thie even is the `Element` that has the transition applied. You can listen for this even on the `Document` interface to handle it in the capture or bubbling phases. 

    This code adds a listener to the `transitionend` event:

        document.addEventListener('transitionend', () =>
            console.log('Transition ended');
        });

    The code below is the same as above, but using the `ontransitionend` property instead of `addEventListener()`:

        document.ontransitionend = () => {
            console.log('Transition ended');
        };

    This code gets an element that has a transition defined and adds a listener to the `transitionend` event (the transition is defined in the CSS): 

        const transition = document.querySelector('.transition');

        transition.addEventListener('transitionend', () => {
            console.log('Transition ended');
        });

    The below function is the same as the above, but using the `ontransitioned`:

        const transition = document.querySelector('transition');

        transition.ontransitionend = () => {
            console.log('Transition ended');
        };

    The following is a like example using a simple <div> element, styled with a transiton that includes a delay:

            <!-- html code -->
            <div class="transition">Hover over me</div>
            <div class="message"></div>

            /* CSS code */
            .transition {
                width: 100px;
                height: 100px;
                background: rgba(255,0,0,1);
                transition-property: transform background;
                transition-duration: 2s;
                transition-delay: 1s;
            }

            .transition:hover {
                transform: rotate(90deg);
                background: rgba(255,0,0,0);
            }

                * To this, we'll add some JavaScript to indicate that the `transitionstart`, `transitionrun`, `transitioncancel` and `transitionend` events fire. In this example, to cancel the transition, stop hoverinng over the transitioning box before the transition ends. For the transition end event to fire, stay hovered over the transition until the transition ends. 

            const message = document.querySelector('.message');
            const el = document.querySelector('.transition');

            el.addEventListener('transitionrun', function() {
            message.textContent = 'transitionrun fired';
            });

            el.addEventListener('transitionstart', function() {
            message.textContent = 'transitionstart fired';
            });

            el.addEventListener('transitioncancel', function() {
            message.textContent = 'transitioncancel fired'; 
            }); 

            el.addEventListener('transitionend', function() {
            message.textContent = 'transitionend fired'; 
            });

        The `transitionend` event is fired in both directions: when the box finishes turning and the opacity hits 0 or 1, depending on the direction. 

        If there is no transition delay or duration, if both are 0s or neither is declared, there is no transiton, and none of the transiton events are fired. 

        If the `transitioncancel` event is fired, the `transitionend` even will not fire. 



/* JS Element.classList */

    The `Element.classList` is a read-only property that returns a live `DOMTokenList` collection of the `class` attributes of the element. This can then be used to manipulate the class list. 

    Using `classList` is a convenient alternative to accessing an element's list of classes as a space-delimited string via `element.className`.

    Syntax 

        const elementClasses = elementNodeReference.classList;

    - Returns 

        A `DOMTokenList` representing the contents of the element's `class` attribute. If the `class` attribute is not set or empty, it returns an empty `DOMTokenList`, ie, a `DOMTokenList` with the `length` property equal to 0. 

        The `DOMTokenList` itself is read-only, although you can modify it using the `add()` and `remove()` methods 

    - Examples 

        const div = document.createElement('div');
        div.className = 'foo';

        // our starting state: <div class="foo"></div>
        console.log(div.outerHTML);

        // use the classList API to remove and add classes
        div.classList.remove("foo");
        div.classList.add("anotherclass");

        // <div class="anotherclass"></div>
        console.log(div.outerHTML);

        // if visible is set remove it, otherwise add it
        div.classList.toggle("visible");

        // add/remove visible, depending on test conditional, i less than 10
        div.classList.toggle("visible", i < 10 );

        // will return true if the elemennt contains the class 
        console.log(div.classList.contains("foo"));

        // add or remove multiple classes
        div.classList.add("foo", "bar", "baz");
        div.classList.remove("foo", "bar", "baz");

        // add or remove multiple classes using spread syntax
        const cls = ["foo", "bar"];
        div.classList.add(...cls); 
        div.classList.remove(...cls);

        // replace class "foo" with class "bar"
        div.classList.replace("foo", "bar");



/* The Audio() Constructor */

    The `Audio()` constructor creates and returns a new `HTMLAudioElement` which an be either attached to a documennt for the usuer to interact with and/or listen to, or can be used offscreen to manage and play audio. 

    - Syntax 

        audioObj = new Audio(url);

    - Parameters 

        An optional `DOMString` containing the URL of an audio file to be associated with the new audio element. 

    - Return value 

        A new `HTMLAudioElement` object, configured to be used for playing back the audio from the file specified by `url`. The new object's `preload` property is set to `auto` annd its `src` property is set to the specified URL or `null` if no URL is given. If a URL is specified, the browser begins to asynchronously load the media resource before returning the new object. 

    You can also use other element-creation methods, such as the `document` object's `createElement()` method, to construct a new `HTMLAudioElement`.

    - Determining when playback can begin 

        There are three ways you can tell when enough of the audio file has loaded to allow playback to begin: 

            1. Check the value of the `readyState` property. If it's `HTMLMediaElement.HAVE_FUTURE_DATA`, there's enough data available to begin playback and play for at least a short time. If it's `HTMLMediaElement.HAVE_ENOUGH_DATA`, then there's enough data availale that, given the current download rate, you should be able to play the audio through to the end without interruption.

            2. Listen for the `canplay` event. It is sent to the <audio> element when there's enough audio available to begin playback, although interruptions may occur. 

            3. Listen for the `canplaythrough` event. It is sent when it's estimated that the audio should be able to play to the end without interruption. 

        The event-based approach is best: 

            myAudioElement.addEventListener("canplaythrough", event => {
                /* the audio is now playable; play it if permissions allow */
                myAudioElement.play();
            });

    - Memory usage and management 

        If all references to an audio element created useing the `Audio()` constructor are deleted, the element itself won't be removed from memory by the JS runtime's garbage collection mechanism if playback is currently underway. instead, the audio will keep playing and the object will remain in memory until playback ends or is paused (such as by calling `pause()`). At that time, the object becomes subject to gargabe collection. 

    * Properties and Methods are inherited from the parent, `HTMLMediaElement`

    - Examples 

        You can create a `HTMLAudioElement` entirely with JS using the `Audio()` constructor.

            let audioElemennt = new Audio('car_horn.wav');

        then you can invoke the `play()` method on the element 

            audioElement.play();

                * Modern browser's default autoplay policy will block play-on-page-load from happening. 
        
        Some of the more commonly used properties of the audio element include `src`, `currentTime`, `duration`, `paused`, `muted`, and `volume`. This snippet copies the audio file's duration to a variable: 

            let audioElement = new Audio('car_horn.wav');
            audioElement.addEventListener('loadeddata', () => {
                let duration = audioElement.duration;
                // The duration variable now holds the duration (in seconds) of the audio clip 
            })

    - Events 

        Inherits methods from its parent, `HTMLMediaElement`, and from its ancestor `HTMLElement`. Listen to events using `addEventListener()` or by assigning an event listener to the `oneventname` property of this interface. 



/* Template Literals ${} */

    Template literals are string literals allowing embedded expressions. You cann use multi-lin strings and string interpolation features with them. 

    - Syntax 

        `string text`

        `string text line 1
        string text line 2`

        `string text ${expression} string text`

        tag`string text ${expression} string text`

    - Description

        Temlate literals are enclosed by the backtick (``) character instead of double or single quotes.

        Template literals can contain placeholders. These are indicated by the dollar sign and curly braces (${expression}). The expressions in the placeholders and the text between the backtick (``) get passed to a function. 

        The default function just concatenates the parts into a single string. If there is an expression preceding the template literal ( tag`string text ${expression} string text` ), this is called a tagged template. In that case, the tag expression (usually a function) gets called with the template literal, which you can then maipulate before outputting.

        To escape a backtick in a template literal, put a backslash (\) before the backtick.

            ` \` ` === '`' // --> true

    - Basic usage: 

        let newString = `A string`;

    - Multi-line strings 

        Any newline characters inserted in the source are part of the template literal.

        Using normal strings, you would have to use the `\n`, or new line character, if we wanted a string to be on multiple lines: 

            // the old way
            let myMultiString = 'Some text that I want\nOn two line!';

            console.log('string text line 1\n' + 
            'string text line 2');
            // "string text line 1
            // string text line 2"

        Using template literals, you can go ahead and add the new line into the string as we write it: 

            let myMultiString = `This well be
            on two lines!`;

            console.log(`string text line 1
            string text line 2`);
            // 'string text line 1
            // string text line 2'

        This will produce a string with a new line in it. The ability to do this with expressions makes Template Literals a really nice templating language for buillding of bits of HTML. But what about conncatenation? 

    - Expression interpolation 

        In order to embed expressions within normal strings, you would use the following syntax: 

            let a = 5;
            let b = 10;
            console.log('Fifteen is ' + (a + b) + ' and\nnot ' + (2 * a + b) + '.');
            // "Fiften is 15 and
            // not 20."

        Now, with template literals, you are able to make use of the syntactic sugar, making substitutions like this more readable: 

            let a = 5;
            let b = 10;
            console.log('Fifteen is ${a + b} and
            not ${2 * a + b}.`);
            // "Fifteen is 15 and 
            // not 20.

        ** Notice how ${expression} removes the need for all of the + and "" or ''. 

            let name = `Ryan`;

            console.log(`Hi my nname is ${name}`);

        The ${} syntax allows us to put an expression in it and it will produce the value (which in the case above is just a variable that holds a string). There is something to note here: if you wanted to add in values, like above, you do not need to use a Template LIteral for the `name` variable. It could just be a regular sting.

            console.log(`Hi my name is ${'Ryan'}`);

        This will produce the same output. These expressions do more than just let us put in variables that contain strings in them. We can evaluate any sort of expressions that we would like.

            let price = 19.99;
            let tax = 1.13;

            let total = `The total prices is ${price * tax}`;

        We can also use this with a more complex object:

            let person = {
                firstName: `Ryan`,
                lastName: `Christiani`,
                sayName() {
                    return `Hi my name is ${this.firstName} ${this.lastName}`;
                }
            };

        Here we have a `person` object with a `sayName()` method on it. We can access the properties from an object inside of the `${}` syntax. 

    - HTML Templates 

        With the ability to have multi-line strings and use Template Expressions to add content into our string, this makes it really nice to use for HTML templates in our code.

        Let's imagine that we get some data from an API that looks something like this:

            {
                "id": 1,
                "name": "Bulbasaur",
                "base_experience": 64,
                "height": 7,
                "is_default": true,
                "order": 1, 
                "weight": 69,
                ...
            }

                * This "imaginary" API is of course the pokeapi (Pokeman API). 

        With this data structure in mind, let's create the markup that would show this Pokeman:

            function createMarkup(data) {
                return `
                    <article class="pokemon">
                        <h3>${data.name}</h3>
                        <p>The Pokemon ${data.name} has a base experience of ${data.base_experience}, they also weigh ${data.weight}</p>
                    </article>
                `
            }

                * The Template Literal allows you to write the exact HTML code with formating using backticks (``). It also allows you to use the Template Expressions ${} to callback data usingthe property names contained in the data that is recieved from the API. 

        Without having to use a library like Handlebars or Mustache we can create nice and easy-to-use templates in our JavaScript!

    - Nesting Templates 

        In certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings.  Within a backticked template, it is simple to allow inner backticks simply by using them inside a placeholder ${} within the template.

        For instance, if condition a is 'true', the 'return' this templated literal.

            In ES5:

                let classes = 'header';
                classes += (isLargeScreen() ?
                    '' : item.isCollapsed ?
                        ' icon-expander' : ' icon-collapser');

                    // classes = 'hearder'
                    // If it is a large screen, add nothing to 'classes'
                    // If it is not a large screen, if item is collapsed, add ' icon-expander' to 'classes'
                        // if item is not collapsed, add ' icon-collapser' to 'classes' 
            
            In ES2015 with template literals and without nesting:

                const classes = 'header ${ isLargeScreen() ? '' :
                    (item.isCollapsed ? 'icon-expander' : 'icon-collapser') }`;

            In ES2015 with nested template literals:

                const classes = `header ${ isLargeScreen() ? '' :
                    `icon-${item.isCollapsed ? 'expander' : 'collapser'}`}`;

    - Tagged Templates 

        Another feature of Template Literals is the ability to create Tagged Template Literals. Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions. You create a function and this function will look like any other function, however it looks different when you call in: 

            function myTaggedLiteral(strings) {
                console.log(strings);
            }

            myTaggedLiteral`test`;
            // ["test"]                     // returns an array of the string in our literal ``

        Notice that there are no perentheses () when we call the function! We apply a Template Literal where the parentheses would be. As a parameter to our function we get an array of the strings in our literal. 
        
        Let's expand on the string we send to the function and we will have it include an expression, and we will include a new parameter in our function as well. 

            function myTaggedLiteral(strings, value) {
                console.log(strings, value);
            }

            let someText = 'Neat';
            myTaggedLiteral`test ${ someText }`;
            // ["test ", ""]                             // array of the strings 
            // "Neat"

        When we use an expression we can access that from the next parameters and this keeps going. Say we added another expression:

            function myTaggedLiteral(strings, value1, value2) {
                console.log(strings, value);
            }

            let someText = 'Neat";
            myTaggedLiteral`test ${someText} ${2 + 3}`;
            // ["test ", ""]
            // "Neat"
            // 5

        This is pretty powerful: it allows you to take the data used in a string and manipulate it to your liking. 

        The tag function can then perform whatever operations you like on its arguments, and return the manipulated string.

        The name of the function used for the tag can be whatever you want.

            let person = 'Mike';
            let age = 28;

            function myTag(strings, personExp, ageExp) {
                let str0 = strings[0];      // "That "
                let str1 = strings[1];      // " is a "
            
                    // There is technically a string after the final expression (in our example), but it is empty (""), so disregard.
                    // let str2 = strings[2]; 

                let ageStr;
                if (ageExp > 99) {
                    ageStr = 'centenarian';
                } else {
                    ageStr = 'youngster';
                }

                // We can even return a string built using a template literal 
                return `${str0}${personExp}${str1}${ageStr}`;
            }

            let output = myTag`That ${ person } is a ${ age }`;
                // When myTag`` is called, it reads the strings and values in order, passing those parameters into the function.  

            console.log(output);
            // That Mike is a youngster

        Tag functions don't even need to return a string. It can return something completely different:

            function template(strings, ...keys) {
                return (function(...values) {
                    let dict = values[values.length -1] || {};
                    let result = [strings[0]];
                    keys.forEach( function(key, i) {
                        let value = Number.isInteger(key) ? values[key] : dict[key];
                        result.push(value, strings[i + 1]);
                    });
                    return result.join('');
                });
            }

                    // strings is the array of strings deteremined by tag``
                    // keys is array of expressions (${}) passed to tag``
                    // values is array of parameters passed from t1Closure('Y', 'A'); 
                    // dict becomes the last element of values[]
                    // result[] is initialized with strings[0] => ("")
                    // forEach() checks each key of keys[] to see if it's an integer, if so it returns the element of values[] to value
                    // value + strings[i + 1] (aka the next string) are appended to result[]
                    // after all keys are checked and appended, result[] is joined into a string and returned


            let t1Closure = template`${0}${1}${0}!`;
                // let t1Closure = template(["","","","!"],0,1,0);
            t1Closure('Y', 'A');        // "YAY!"

            let t2Closure = template`${0} ${'foo'}!`;
                // let t2Closure = template([""," ","!"],0,"foo");
            t2Closure('Hello', {foo: 'World'});     // "Hello World!"

            let t3Closure = template`I'm ${'name'}. I'm almost ${'age'} years old.`;
                // let t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
            t3Closure('foo', {name: 'MDN', age: 30});   // "I'm MDN. I'm almost 30 years old."
            t3Closure({name: 'MDN', age: 30})

        ** to see the above code in action, check out lcr-coding-files/vscode-cheatsheets/JavaScript/lcr-js-function-library/template-literals.html
            
    - Raw Strings 

        The special `raw` peroperty, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences (\n). 

            function tag(strings) {
                console.log(strings.raw[0]);
            }

            tag`string text line 1 \n string text line 2`;
            // logs "string text line 1 \n string text line 2", including the two characerts '\' and 'n'
        
        In addition, the `String.raw()` method exists to create raw strings - just like the default template function and string concatenation would create. 

            let str - String.raw`Hi\n${2+3}!`;
            // "Hi\n5!"

            str.length;
            // 6

            Array.from(str).join(',');
            // "H,i,\,n,5,!"

    - Reusable Templates 

        Let's look at a simple use case for Template Literals. If you remember from above, we saw how Template LIterals work really great for making templates! Let's take that a step further and create a function that would allow us to create reusable templates. The idea here is that we can create the initial template and then pass in data for it to use later. 

            const student = {
                name: 'Ryan Christiani',
                blogUrl: 'http://ryanchristiani.com'
            }

            const studentTemplate = templater`<article>
                    <h3>${'name'} is a student at HackerYou</h3>
                    <p>You can find their work at ${'blogUrl'}.</p>
                </article>`;

            const myTemplate = studentTemplate(student);    // passes 'student' object to 'templater'
            console.log(myTemplate);

            // Output will look like this!
            //  <article>
            //      <h3>Ryan Christiani is a student at HackerYou</h3>
            //      <p>You can find their work at http://ryanchristiani.com.</p>
            //  </article>

        Let's look at implementing our `templater` function:

            const templater = function(strings, ...keys) {

            }

        The first thing you will notice is the `...keys` parameter. The `...` syntax is what's called Rest Parameters; it will gather any parameters the function has and create an array keys[] for us. 

        The next thing we want to do is return a function that is going to access our object. The returning of the function is what allows us to call and pass in our student data, like this: `studentTemplate(student)`. 

            const templater = function(strings, ...keys) {
                return function(data) {

                }
            }

        With this data now available to us we need to perform some manipulation. The process is as follows. First, we need to create a copy of the `strings` array. We make a copy in case we want to reference the original later. Then we need to loop through the array of `keys`, and for each one of those, grab the data from the object that matches the key (notice how in theis example we pass in a string in the `${}`) and place it in our array where needed. Finally, we need to join it all back together as a string and return it from the function. 

            function templater(string, ...keys) {
                return function(data) {             // returns a function that passes 'data'
                    let temp = strings.slice();     // creates/copies a new array 
                    keys.forEach((key,i) => {       // loops thru keys and adds data[key] to each temp[i]
                        temp[i] = temp[i] + data[key];
                    });
                    return temp.join('');           // returns joined array as a string with no separator
                }
            };

        You will notice that this is not an exhaustive example. We have no way to accommodate nested data or array values; it is simply just strings. But this example helps illustrate what you can start doing with Tagged Template Literals. 



/* JS DOM Methods */ 

    - Finding Elements

        `document.NODE.getElementsByTagName` - colects all elements with the given tag name that are descendants (direct or indirect children) of that node and returns them as an array-like object.

            Example: let link = document.body.getElementsByTagName('a')[0];
                    console.log(link.href);

        `document.getElementById` - finds a specific SINGLE node given it's id attribute.

            Example: let ostrich = document.getElementById('gertrude');
                    console.log(ostrich.src);

        `document.NODE.getElementsByClassName` - searches through the contents of an element node and retrieves all elements that have the given string in their 'class' attribute. 

            Example: let birds = document.body.getElementsByClassName('birds');

    - Changing the Document 

        Almost everything about the Dom data structure can be changed. 

        `document.NODE.remove` - removes a node from it's current parent node.

        `document.NODE.appendChild` - adds a child node to an element node and puts it at the end of the list of children.

        `document.NODE.insertBefore` - inserts the node given as the first argument before the node given as the second argument. 

            Example: let paragraphs = document.body.getElementsByTagName('p');
                     document.body.insertBefore(paragraphs[2], paragraphs[0]);

        `document.NODE.replaceChild` - replaces a child node with another one. It takes as arguments two nodes: a new node and the node to be replaced. The replaced node must be a child of the element the method is called on. NOTE THAT both `replaceChild` and `insertBefore` expect the new node as their first argument. 

            document.body.replaceChild( 'newNode', 'replacedNode' );
        
        ** A node can exist in the document in only one place. All operations that insert a node somewhere will, as a side effect, cause it to be removed from its current position (if it has one).

    - Creating Nodes 

        `document.createTextNode` - given a string, creates a text node that we can insert into the document to make it appear on screen. 

        ``
